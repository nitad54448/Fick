<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Onsager Diffusion v8.4</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    
    <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
<style>
    /* --- 1. Variables & Reset --- */
    :root {
        /* Core Palette */
        --bg-app: #f1f5f9;       /* Slate-100 */
        --bg-panel: #ffffff;
        --border: #e2e8f0;       /* Slate-200 */
        
        /* Text Colors */
        --text-main: #0f172a;    /* Slate-900 */
        --text-muted: #64748b;   /* Slate-500 */
        
        /* Brand Colors */
        --primary: #ea580c;      /* Orange-600 */
        --primary-light: #fff7ed;/* Orange-50 */
        --accent: #4f46e5;       /* Indigo-600 */
        --accent-light: #eef2ff; /* Indigo-50 */
        
        /* Semantic Colors */
        --danger: #ef4444;
        --success: #10b981;
        --warning-bg: #fffbeb;
        --warning-border: #f59e0b;
    }

    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        background-color: var(--bg-app);
        color: var(--text-main);
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    /* --- 2. App Header --- */
    .app-header {
        height: 56px;
        background: var(--bg-panel);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 16px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        z-index: 10;
        flex-shrink: 0;
    }

    .brand { display: flex; align-items: center; gap: 12px; }
    .brand-icon {
        width: 32px; height: 32px;
        background-color: var(--primary);
        color: white;
        border-radius: 6px;
        display: flex; align-items: center; justify-content: center;
    }
    .brand h1 { font-size: 18px; margin: 0; font-weight: 700; color: var(--text-main); }
    .brand span { font-size: 12px; font-weight: 400; color: var(--text-muted); margin-left: 5px; }

    /* Status Bar */
    .status-area {
        flex: 1;
        margin: 0 32px;
        display: flex;
        align-items: center;
        gap: 12px;
        opacity: 0;
        transition: opacity 0.3s;
    }
    .progress-track {
        flex: 1;
        height: 6px;
        background: var(--bg-app);
        border-radius: 10px;
        overflow: hidden;
    }
    .progress-bar {
        height: 100%;
        background: var(--primary);
        width: 0%;
        transition: width 0.2s;
    }
    .status-text { 
        font-family: "Menlo", "Consolas", monospace; 
        font-size: 12px; 
        color: var(--text-muted); 
        min-width: 60px; 
        text-align: right; 
    }
    .stop-btn { border: none; background: none; color: var(--danger); cursor: pointer; font-size: 14px; }

    /* Navigation Tabs */
    .nav-tabs { display: flex; height: 100%; gap: 4px; }
    .tab-btn {
        background: none;
        border: none;
        height: 100%;
        padding: 0 16px;
        color: var(--text-muted);
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        border-bottom: 2px solid transparent;
        transition: all 0.2s;
        display: flex; align-items: center; gap: 8px;
    }
    .tab-btn:hover { background-color: var(--bg-app); color: var(--text-main); }
    .tab-btn.active {
        background-color: var(--accent-light);
        color: var(--accent);
        border-bottom-color: var(--accent);
    }
    .tab-btn.help-btn { color: #059669; } /* Green for help */

    /* --- 3. Layout: Sidebar & Content --- */
    .main-container {
        display: flex;
        flex: 1;
        overflow: hidden;
        position: relative;
    }

    /* Sidebar */
    .sidebar {
        width: 320px;
        background: var(--bg-panel);
        border-right: 1px solid var(--border);
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        padding: 16px;
        gap: 20px;
        flex-shrink: 0;
        box-shadow: 4px 0 24px rgba(0,0,0,0.02);
        z-index: 5;
    }

    /* Control Panels */
    .control-panel {
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 12px;
        background: #fafafa;
    }
    .panel-orange { background: var(--primary-light); border-color: #fed7aa; }
    .panel-indigo { background: var(--accent-light); border-color: #c7d2fe; }
    
    .panel-header {
        display: flex; align-items: center; gap: 8px;
        margin-bottom: 12px;
        border-bottom: 1px solid rgba(0,0,0,0.06);
        padding-bottom: 8px;
    }
    .panel-title {
        font-size: 11px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.5px; margin: 0;
        color: var(--text-muted);
    }
    .text-orange { color: #9a3412; }
    .text-indigo { color: #3730a3; }

    /* Inputs */
    .input-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .col-span-2 { grid-column: span 2; }
    
    .input-group label {
        display: block;
        font-size: 10px;
        font-weight: 700;
        margin-bottom: 4px;
        color: var(--text-muted);
    }
    .input-group input, .input-group select {
        width: 100%;
        padding: 6px 8px;
        font-size: 13px;
        border: 1px solid var(--border);
        border-radius: 4px;
        outline: none;
        background: white;
        color: var(--text-main);
        transition: border-color 0.2s;
    }
    .input-group input:focus { 
        border-color: var(--accent); 
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1); 
    }

    /* Element Card (Dynamic List) */
    .element-card {
        background: white;
        border: 1px solid var(--border);
        border-left-width: 4px; /* Color defined inline in JS */
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 10px;
        position: relative;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        transition: transform 0.1s;
    }
    .element-card:hover { transform: translateY(-1px); box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05); }
    
    .element-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
    }
    .grid-full { grid-column: 1 / -1; }
    
    .delete-btn {
        position: absolute; top: 6px; right: 6px;
        border: none; background: none; color: #cbd5e1;
        cursor: pointer; display: none; padding: 4px;
    }
    .element-card:hover .delete-btn { display: block; }
    .delete-btn:hover { color: var(--danger); }

    /* Sidebar Buttons */
    .btn {
        border: none; border-radius: 6px; padding: 8px 12px;
        font-size: 11px; font-weight: 700; cursor: pointer;
        display: inline-flex; align-items: center; justify-content: center; gap: 6px;
        transition: all 0.2s;
        text-transform: uppercase; letter-spacing: 0.5px;
    }
    .btn-add { background: var(--accent); color: white; float: right;}
    .btn-add:hover { background: #4338ca; }
    
    .btn-download { 
        width: 100%; 
        background: white; 
        border: 1px solid var(--border);
        color: var(--text-muted); 
        margin-top: 16px; 
    }
    .btn-download:hover { background: #f8fafc; color: var(--text-main); border-color: #cbd5e1; }

    /* --- 4. Main Content Area & Charts --- */
    .content-area {
        flex: 1;
        background: var(--bg-app);
        position: relative;
        overflow: hidden;
    }
    .tab-pane {
        display: none;
        width: 100%; height: 100%;
        position: absolute; top: 0; left: 0;
        overflow-y: auto; /* Enable scrolling for help */
    }
    .tab-pane.active { display: block; }

    .chart-wrapper {
        background: white;
        margin: 16px;
        border-radius: 12px;
        border: 1px solid var(--border);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
        height: calc(100% - 32px);
        padding: 16px;
        position: relative;
    }
    #plotly-flux, #plotly-time { width: 100%; height: 100%; }

    /* --- 5. Help Section  */
    
    .help-container {
        padding: 40px;
        max-width: 900px;
        margin: 0 auto;
        background: #ffffff;
        color: #334155;
        line-height: 1.6;
        min-height: 100%;
    }

    /* Header */
    .help-header {
        margin-bottom: 40px;
        border-bottom: 2px solid #f1f5f9;
        padding-bottom: 20px;
    }
    .help-header h1 {
        font-size: 28px;
        color: #0f172a;
        font-weight: 700;
        margin: 0 0 8px 0;
        letter-spacing: -0.5px;
    }
    .help-header p {
        color: #64748b;
        font-size: 14px;
        font-family: "Menlo", monospace;
    }

    /* Sections */
    .help-section { margin-bottom: 60px; }
    
    .help-title {
        font-size: 20px;
        font-weight: 600;
        color: #1e293b;
        margin-bottom: 24px;
        display: flex;
        align-items: center;
        gap: 12px;
    }
    
    .step-badge {
        background: #434777;
        color: white;
        font-family: "Menlo", monospace;
        font-size: 14px;
        width: 28px; height: 28px;
        border-radius: 6px;
        display: flex; align-items: center; justify-content: center;
    }

/* Math Blocks (Clean / Transparent) */
.math-block {
    background: transparent;      
    border: none;                  /* No border */
    padding: 16px 0;               /* Vertical spacing only */
    margin: 16px 0;
    overflow-x: auto;
    text-align: center;
    font-size: 1.25em;             
    color: #1e293b;
    font-family: "Times New Roman", Times, serif; 
}

    /* Theory Boxes */
    .theory-box {
        background: #fff;
        border-left: 4px solid #cbd5e1;
        padding: 20px;
        margin: 24px 0;
        border-radius: 0 8px 8px 0;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
    }
    .theory-box h4 { 
        margin: 0 0 10px 0; 
        color: #334155; 
        font-size: 13px; 
        font-weight: 800;
        text-transform: uppercase; 
        letter-spacing: 0.5px; 
    }
    .theory-box p { margin-bottom: 0; }

    /* Box Variations */
    .box-warning { border-left-color: var(--warning-border); background: var(--warning-bg); }
    .box-info    { border-left-color: #3b82f6; background: #eff6ff; }
    
    /* Visualization Grid */
    .viz-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-top: 20px;
    }
    .viz-card {
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 20px;
        transition: transform 0.2s, border-color 0.2s;
    }
    .viz-card:hover { border-color: #94a3b8; transform: translateY(-2px); }
    .viz-icon {
        font-size: 20px; margin-bottom: 12px; color: var(--accent);
        background: var(--accent-light); width: 40px; height: 40px;
        display: flex; align-items: center; justify-content: center;
        border-radius: 8px;
    }

    /* Reference Tables */
    .data-table-wrapper {
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        overflow: hidden;
        margin-top: 16px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    .theory-table { width: 100%; border-collapse: collapse; font-size: 13px; }
    .theory-table th {
        background: #f8fafc;
        color: #475569;
        font-weight: 700;
        padding: 12px 16px;
        text-align: left;
        border-bottom: 1px solid #e2e8f0;
    }
    .theory-table td {
        padding: 12px 16px;
        border-bottom: 1px solid #f1f5f9;
        color: #334155;
        vertical-align: top;
    }
    .theory-table tr:last-child td { border-bottom: none; }
    
    /* Tags in Tables */
    .val-mono { font-family: "Menlo", monospace; font-weight: 700; color: #0f172a; }
    .type-tag { 
        display: inline-block; padding: 3px 10px; border-radius: 12px; 
        font-size: 11px; font-weight: 700; 
    }
    .text-ideal { background: #dcfce7; color: #166534; }
    .text-repulsive { background: #fef3c7; color: #92400e; }
    .text-ordering { background: #e0e7ff; color: #3730a3; }
    .text-phase { background: #ffe4e6; color: #9f1239; }

    /* Scrollbars */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

    @media (max-width: 768px) {
        .app-header h1 { display: none; }
        .sidebar { position: absolute; height: 100%; transform: translateX(-100%); transition: transform 0.3s; }
        .sidebar.open { transform: translateX(0); }
        .help-container { padding: 20px; }
    }
</style>

</head>
<body>

    <header class="app-header">
        <div class="brand">
            <div class="brand-icon">
                <i class="fas fa-project-diagram"></i>
            </div>
            <div>
                <h1>Onsager Diffusion <span>v8.4</span></h1>
            </div>
        </div>
        
        <div id="status-area" class="status-area">
            <div class="progress-track">
                <div id="header-progress" class="progress-bar"></div>
            </div>
            <span id="header-status" class="status-text">Calculating...</span>
            <button onclick="terminateWorker()" class="stop-btn" title="Stop">
                <i class="fas fa-stop"></i>
            </button>
        </div>

        <nav class="nav-tabs">
            <button onclick="switchTab('profile')" id="tab-profile" class="tab-btn active">
                <i class="fas fa-chart-line"></i> Profile
            </button>
            <button onclick="switchTab('flux')" id="tab-flux" class="tab-btn">
                <i class="fas fa-water"></i> 3D Flux
            </button>
            <button onclick="switchTab('time3d')" id="tab-time3d" class="tab-btn">
                <i class="fas fa-cube"></i> 3D Conc
            </button>
            <button onclick="switchTab('help')" id="tab-help" class="tab-btn help-btn">
                <i class="fas fa-info-circle"></i> Theory
            </button>
        </nav>
    </header>

    <div class="main-container">
        
        <aside class="sidebar">
            
            <div class="control-panel panel-orange">
                <div class="panel-header text-orange">
                    <i class="fas fa-ruler-combined"></i>
                    <h3 class="panel-title">1. Geometry</h3>
                </div>
                <div class="input-grid">
                    <div class="input-group">
                        <label>Source Length (µm)</label>
                        <input type="number" id="sourceLength" value="5" min="0.1" step="0.1" onchange="debouncedUpdate()">
                    </div>
                    <div class="input-group">
                        <label>Total Length (µm)</label>
                        <input type="number" id="totalLength" value="20" min="1" step="1" onchange="debouncedUpdate()">
                    </div>
                    <div class="input-group col-span-2">
                        <label>Grid Points</label>
                        <input type="number" id="gridPoints" value="100" min="50" max="400" onchange="debouncedUpdate()">
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <div class="panel-header">
                    <h3 class="panel-title">2. Conditions</h3>
                </div>
                <div class="input-grid">
                    <div class="input-group">
                        <label>Temp (K)</label>
                        <input type="number" id="temp" value="1050" min="600" max="2800" onchange="debouncedUpdate()">
                    </div>
                    <div class="input-group">
                        <label>Time (Hours)</label>
                        <input type="number" id="time" value="72" min="0.1" step="0.1" onchange="debouncedUpdate()">
                    </div>
                </div>
            </div>

            <div class="control-panel panel-indigo">
                <div class="panel-header text-indigo">
                    <h3 class="panel-title">3. Matrix (MgO)</h3>
                </div>
                <div class="input-grid">
                    <div class="input-group">
                        <label>D₀ (m²/s)</label>
                        <input type="text" id="targetD0" value="5.0e-11" onchange="debouncedUpdate()">
                    </div>
                    <div class="input-group">
                        <label>Q (eV)</label>
                        <input type="number" id="targetQ" value="2.0" step="0.1" onchange="debouncedUpdate()">
                    </div>
                </div>
            </div>

            <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h3 class="panel-title">4. Dopants</h3>
                    <button onclick="addElement()" class="btn btn-add">
                        <i class="fas fa-plus"></i> ADD
                    </button>
                </div>
                <div id="elementsList"></div>
                
                <button onclick="downloadData()" class="btn btn-download">
                    <i class="fas fa-download"></i> Download CSV
                </button>
            </div>
        </aside>

        <main class="content-area">
            
            <div id="pane-profile" class="tab-pane active">
                <div class="chart-wrapper">
                    <canvas id="diffusionChart"></canvas>
                </div>
            </div>

            <div id="pane-flux" class="tab-pane">
                 <div id="plotly-flux"></div>
            </div>

            <div id="pane-time3d" class="tab-pane">
                 <div id="plotly-time"></div>
            </div>


            <div id="pane-help" class="tab-pane">
    <div class="help-container">
        
        <div class="help-header">
            <h1>Documentation & Theory</h1>
            <p>Onsager Multi-Component Diffusion Solver (v8.4) • December 7, 2025</p>
        </div>

        <div class="theory-box box-warning">
            <h4><i class="fas fa-exclamation-triangle"></i> Parameter Warning</h4>
            <p>
                Default values ($D_0, Q$) are tuned for <strong>MgO</strong>. 
                For other matrices, you must update these parameters in the settings panel. 
                The solver assumes $D_0$ and $Q$ do not depend on concentration.
            </p>
        </div>

        <div class="help-section">
            <h2 class="help-title"><span class="step-badge">1</span> From Fick to Onsager: Multi-Component Diffusion</h2>

            <p>
                In a single-component system, diffusion is driven solely by the concentration gradient of that species. 
                Fick's First Law describes the flux as proportional to this gradient:
            </p>

            <div class="math-block">
                $$ J = -D \, \nabla C $$
            </div>

            <p>
                Here, $D$ is the <strong>diffusion coefficient</strong> (units: m²/s), which measures how rapidly atoms move down their concentration gradient. 
                The negative sign ensures that flux flows from high to low concentration.
            </p>

            <div class="theory-box">
                <h4>What is the Diffusion Coefficient $D$?</h4>
                <p>
                    The diffusion coefficient quantifies atomic mobility. It depends on temperature through the Arrhenius equation:
                </p>
                <div class="math-block">
                    $$ D(T) = D_0 \exp\left( -\frac{Q}{k_B T} \right) $$
                </div>
                <p>
                    <strong>$D_0$</strong> (pre-exponential factor) captures the attempt frequency and lattice geometry.<br>
                    <strong>$Q$</strong> (activation energy) is the energy barrier for an atom to jump to a neighboring site.<br>
                    <strong>$k_B$</strong> is Boltzmann's constant (8.617×10⁻⁵ eV/K).<br>
                    <strong>$T$</strong> is absolute temperature (K).
                </p>
                <p>
                    Higher temperatures exponentially increase $D$, allowing atoms to overcome barriers more easily.
                </p>
            </div>

            <div class="theory-box box-info">
                <h4>Fick's Second Law: Time Evolution</h4>
                <p>
                    Combining Fick's First Law with mass conservation ($\partial C/\partial t = -\nabla \cdot J$) yields 
                    Fick's Second Law, which governs how concentrations change over time:
                </p>
                <div class="math-block">
                    $$ \frac{\partial C}{\partial t} = \nabla \cdot \left( D \, \nabla C \right) = D \, \nabla^2 C $$
                </div>
                <p>
                    (assuming $D$ is constant in space). This is the classic diffusion equation: concentrations smooth out over time, 
                    with sharper gradients diffusing faster.
                </p>
            </div>

            <h3 style="margin-top: 30px; font-size: 16px; font-weight: 600; color: #1e293b;">Multi-Component Systems: The Onsager Framework</h3>

            <p>
                When multiple species diffuse simultaneously (e.g., dopants Ni²⁺, Co²⁺, Fe²⁺ in MgO), they interact. 
                In vacancy-mediated diffusion, all species compete for the <em>same vacancies</em>. This creates <strong>cross-coupling</strong>: 
                a gradient in species $j$ can drive a flux in species $i$, even if $i$ has no gradient.
            </p>

            <p>
                The Onsager formalism generalizes Fick's law to account for these interactions. Instead of a single coefficient $D$, 
                we have a <strong>diffusion matrix</strong> $D_{ij}$:
            </p>

            <div class="math-block">
                $$ J_i = -\sum_j D_{ij}(C,T) \, \nabla C_j $$
            </div>

            <p>
                <strong>Diagonal terms</strong> ($D_{ii}$): Self-diffusion of species $i$ driven by its own gradient.<br>
                <strong>Off-diagonal terms</strong> ($D_{ij}$, $i \neq j$): Cross-diffusion, where species $i$ responds to gradients in species $j$.
            </p>

            <div class="theory-box">
                <h4>What is the Onsager Approximation?</h4>
                <p>
                    Onsager's reciprocal relations state that the diffusion matrix must satisfy certain symmetry constraints based on 
                    microscopic reversibility. In the context of vacancy-mediated diffusion, the Onsager framework provides a rigorous 
                    way to calculate $D_{ij}$ from the individual tracer diffusivities and local concentrations.
                </p>
                <p>
                    The key insight: all species share the same vacancy mechanism, so their motions are fundamentally coupled. 
                    The Manning–Darken model (Section 2) gives explicit expressions for $D_{ij}$ consistent with Onsager's principles.
                </p>
            </div>

            <div class="theory-box box-info">
                <h4>Time Evolution in Multi-Component Systems</h4>
                <p>
                    Just as in the single-component case, we combine the generalized flux law with mass conservation to obtain:
                </p>
                <div class="math-block">
                    $$ \frac{\partial C_i}{\partial t} = \nabla \cdot \left( \sum_{j} D_{ij} \, \nabla C_j \right) $$
                </div>
                <p>
                    This is the governing equation solved by this tool. Unlike Fick's Second Law, the matrix $D_{ij}$ depends on 
                    the local concentrations of <em>all</em> species, so it must be recalculated at every spatial point and every timestep. 
                    This dynamic coupling produces surprising effects:
                </p>
                <ul style="margin-top: 10px; padding-left: 20px; font-size: 14px;">
                    <li><strong>Uphill diffusion:</strong> Species can move <em>against</em> their own gradient.</li>
                    <li><strong>Kirkendall effect:</strong> Asymmetric diffusion shifts the original interface.</li>
                    <li><strong>Vacancy wind:</strong> Fast-diffusing species "drag" slower species along.</li>
                </ul>
            </div>

            <div class="theory-box">
                <h4>1.1 Tracer Diffusivities $D_i^*$</h4>
                <p>
                    Each species (including the matrix cations, e.g., Mg²⁺ in MgO) has an intrinsic <strong>tracer diffusivity</strong> 
                    $D_i^*(T)$, which is the diffusion coefficient measured in a dilute limit when the species does not interact with others:
                </p>
                <div class="math-block">
                    $$ D_i^*(T) = D_{0,i} \, \exp\left( -\frac{Q_i}{k_B T} \right) $$
                </div>
                <p>
                    These $D_i^*$ values are the <em>inputs</em> to the Onsager diffusion matrix. They capture how easily each species 
                    jumps through the lattice in isolation. The matrix $D_{ij}$ is constructed from these tracer diffusivities plus 
                    concentration-dependent corrections.
                </p>
            </div>

        </div>

        <div class="help-section">
            <h2 class="help-title"><span class="step-badge">2</span> The Manning–Darken Model: Building the Diffusion Matrix</h2>

            <p>
                In crystalline materials like MgO, cation diffusion occurs primarily through the <strong>vacancy mechanism</strong>: 
                an atom jumps into a neighboring vacant lattice site. All cation species (Mg²⁺, Ni²⁺, Co²⁺, etc.) share the same 
                pool of cation vacancies. This shared mechanism creates the cross-coupling described by the Onsager matrix.
            </p>

            <p>
                The <strong>Manning–Darken model</strong> provides explicit formulas for the diffusion matrix elements $D_{ij}$ 
                in terms of the tracer diffusivities $D_i^*$ and local concentrations $C_i$. These expressions respect Onsager's 
                reciprocal relations and capture the physics of vacancy-mediated transport.
            </p>

            <div class="theory-box">
                <h4>2.1 Diagonal Elements (Self-Diffusion)</h4>
                <p>
                    The diagonal elements $D_{ii}$ describe how species $i$ responds to its own concentration gradient:
                </p>
                <div class="math-block">
                    $$ D_{ii} = D_i^* + C_i \left( D_{\text{matrix}}^* - D_i^* \right) $$
                </div>
                <p>
                    <strong>Physical interpretation:</strong> At low concentration ($C_i \to 0$), $D_{ii} \approx D_i^*$ recovers the tracer limit. 
                    As $C_i$ increases, the effective diffusivity blends toward the matrix diffusivity $D_{\text{matrix}}^*$ (the tracer 
                    diffusivity of the host cations, e.g., Mg²⁺ in MgO). This reflects the fact that in a concentrated alloy, the 
                    environment becomes more like the matrix.
                </p>
            </div>

            <div class="theory-box">
                <h4>2.2 Off-Diagonal Elements (Cross-Diffusion)</h4>
                <p>
                    The off-diagonal elements $D_{ij}$ ($i \neq j$) describe how species $i$ responds to gradients in species $j$:
                </p>
                <div class="math-block">
                    $$ D_{ij} = C_i \left( D_{\text{matrix}}^* - D_j^* \right) $$
                </div>
                <p>
                    <strong>Physical interpretation:</strong> This term arises from the vacancy wind effect. When species $j$ diffuses 
                    (creating a flux of $j$-atoms), it generates a counter-flow of vacancies. Species $i$ can "surf" on this vacancy 
                    current, causing a flux of $i$-atoms even when $i$ has no concentration gradient.
                </p>
                <p>
                    If $D_j^* \ll D_{\text{matrix}}^*$ (slow dopant), then $D_{ij} > 0$: a gradient in $j$ pulls $i$ along.<br>
                    If $D_j^* \gg D_{\text{matrix}}^*$ (fast dopant), then $D_{ij} < 0$: species $i$ moves <em>against</em> the $j$-gradient.
                </p>
            </div>

            <div class="theory-box box-info">
                <h4>2.3 Why the Matrix Diffusivity Appears</h4>
                <p>
                    The quantity $D_{\text{matrix}}^*$ is the tracer diffusivity of the matrix cations (e.g., Mg²⁺ in MgO). 
                    It sets the reference scale for vacancy motion. In a pure MgO crystal, vacancies would move at a rate determined by 
                    Mg²⁺ jumps. When dopants are added, their different jump rates create local imbalances in the vacancy concentration, 
                    which couples all species together.
                </p>
                <p>
                    The Manning–Darken expressions naturally interpolate between two limits:<br>
                    <strong>(1)</strong> Dilute limit ($C_i \to 0$): Each dopant sees only the matrix, so $D_{ii} \to D_i^*$ and cross-terms vanish.<br>
                    <strong>(2)</strong> Concentrated limit: The environment becomes dominated by the alloy composition, and all diffusivities 
                    blend toward a common effective value.
                </p>
            </div>

            <div class="theory-box">
                <h4>2.4 Final Flux Law with Thermodynamic Corrections</h4>
                <p>
                    The Manning–Darken expressions give the <em>kinetic</em> diffusion matrix. In non-ideal solutions, we must also 
                    account for thermodynamic driving forces (chemical potential gradients). The solver includes these effects through 
                    the thermodynamic factor $\Phi_i$:
                </p>
                <div class="math-block">
                    $$ J_i(x) = \Phi_i(x) \left[ -\sum_j D_{ij}(x) \, \nabla C_j(x) \right] $$
                </div>
                <p>
                    For a regular solution (Section 5), $\Phi_i$ depends on the interaction parameter $\Omega$:
                </p>
                <div class="math-block">
                    $$ \Phi_i = 1 - \frac{2 \Omega \, C_i(1 - C_i)}{k_B T} $$
                </div>
                <p>
                    When $\Phi_i < 0$, the system enters the spinodal region and phase separates (uphill diffusion occurs naturally). 
                    When $\Phi_i > 1$, thermodynamic repulsion accelerates diffusion. This thermodynamic correction multiplies the 
                    kinetic flux, capturing effects like interface sharpening and demixing.
                </p>
            </div>

        </div>

        <div class="help-section">
            <h2 class="help-title"><span class="step-badge">3</span> Numerical Algorithm & Stability</h2>
            
            <p>
                The solver uses an explicit finite-difference scheme. Because the system is strongly coupled, 
                numerical stability depends on the largest eigenvalue of the diffusion matrix.
            </p>

            <div class="math-block">
                $$ \Delta t \le \frac{\Delta x^2}{2\,\lambda_{\max}} $$
            </div>

            <p>
                Instead of computing eigenvalues explicitly, the code uses <strong>Gershgorin bounds</strong> 
                to estimate $\lambda_{\max}$ locally at every grid point. This ensures stability even for 
                systems with strong coupling or highly unequal diffusivities.
            </p>
        </div>

        <div class="help-section">
            <h2 class="help-title"><span class="step-badge">4</span> Viewing the Results</h2>
            <div class="viz-grid">
                <div class="viz-card">
                    <div class="viz-icon"><i class="fas fa-chart-line"></i></div>
                    <strong>Concentration (2D)</strong>
                    <p style="font-size:13px; color:var(--text-muted); margin-top:8px;">
                        Standard diffusion curves.
                        <br>• <strong>Asymmetry:</strong> Kirkendall shift.
                        <br>• <strong>Local bumps:</strong> Vacancy drag.
                        <br>• <strong>Flat zones:</strong> Flux cancellation.
                    </p>
                </div>

                <div class="viz-card">
                    <div class="viz-icon"><i class="fas fa-water"></i></div>
                    <strong>Flux Surface (3D)</strong>
                    <p style="font-size:13px; color:var(--text-muted); margin-top:8px;">
                        A time–position surface plot of $J(x,t)$.
                        <br>• <strong>Reversal:</strong> Flux changing sign.
                        <br>• <strong>Ridges:</strong> Tilted flow paths.
                    </p>
                </div>

                <div class="viz-card">
                    <div class="viz-icon"><i class="fas fa-cube"></i></div>
                    <strong>Time Traces (3D)</strong>
                    <p style="font-size:13px; color:var(--text-muted); margin-top:8px;">
                        Evolution of concentration markers.
                        <br>• <strong>Backwards movement:</strong> Uphill diffusion.
                        <br>• <strong>Crossing:</strong> Species overtaking.
                    </p>
                </div>
            </div>
        </div>

        <div class="help-section">
            <h2 class="help-title"><span class="step-badge">5</span> Non-Ideal Thermodynamics ($\Omega$)</h2>
            
            <p>
                Deviations from ideal mixing are included through the regular-solution 
                parameter $\Omega$. It modifies the chemical potential curvature:
            </p>
            <div class="math-block">
                $$ \Phi = 1 - \frac{2\Omega\, C(1-C)}{k_B T} $$
            </div>
            
            <div class="theory-box box-rose">
                <h4>Spinodal Decomposition</h4>
                <p>
                    If <strong>$\Phi < 0$</strong>, the system is in the <strong>spinodal region</strong>.
                    Diffusion drives demixing (phase separation) instead of smoothing. 
                    <br><br>
                    • <strong>$\Omega = 0$:</strong> Ideal solution.<br>
                    • <strong>$\Omega > 0$:</strong> Repulsive (miscibility gaps possible).<br>
                    • <strong>Large $\Omega$:</strong> Sharp interfaces.
                </p>
            </div>
        </div>

        <div class="help-section">
            <h2 class="help-title"><span class="step-badge">6</span> Reference Values ($\Omega$)</h2>
            <p>Experimental thermodynamic assessments ($1 \text{ kJ/mol} \approx 0.0104 \text{ eV}$).</p>

            <div class="data-table-wrapper">
                <table class="theory-table">
                    <thead>
                        <tr>
                            <th>System (Matrix-Dopant)</th>
                            <th>$\Omega$ (eV)</th>
                            <th>Type</th>
                            <th>Physical Reason</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="background:#f8fafc"><td colspan="4" style="font-weight:700; color:#64748b; font-size:11px; text-transform:uppercase;">MgO Matrix</td></tr>
                        <tr>
                            <td><strong>MgO - NiO</strong></td>
                            <td class="val-mono">0.00</td>
                            <td><span class="type-tag text-ideal">Ideal</span></td>
                            <td>Complete solid solution (Similar radii).</td>
                        </tr>
                        <tr>
                            <td><strong>MgO - CoO</strong></td>
                            <td class="val-mono">0.05</td>
                            <td><span class="type-tag text-ideal">Near Ideal</span></td>
                            <td>Very slight repulsion.</td>
                        </tr>
                        <tr>
                            <td><strong>MgO - FeO</strong></td>
                            <td class="val-mono">0.04</td>
                            <td><span class="type-tag text-ideal">Near Ideal</span></td>
                            <td>Mixes well at high Temp.</td>
                        </tr>
                        <tr>
                            <td><strong>MgO - ZnO</strong></td>
                            <td class="val-mono">0.18</td>
                            <td><span class="type-tag text-repulsive">Repulsive</span></td>
                            <td>Structural mismatch (Rock Salt vs Wurtzite).</td>
                        </tr>
                        <tr>
                            <td><strong>MgO - CuO</strong></td>
                            <td class="val-mono">0.21</td>
                            <td><span class="type-tag text-repulsive">Repulsive</span></td>
                            <td>Jahn-Teller distortion.</td>
                        </tr>
                        <tr>
                            <td><strong>MgO - CaO</strong></td>
                            <td class="val-mono">0.55</td>
                            <td><span class="type-tag text-phase">Miscibility Gap</span></td>
                            <td>Ca²⁺ is large. Phase separates &lt; 2000K.</td>
                        </tr>
                        <tr>
                            <td><strong>MgO - Cr₂O₃</strong></td>
                            <td class="val-mono">> 0.80</td>
                            <td><span class="type-tag text-phase">Precipitation</span></td>
                            <td>Solubility limit simulation.</td>
                        </tr>

                        <tr style="background:#f8fafc"><td colspan="4" style="font-weight:700; color:#64748b; font-size:11px; text-transform:uppercase;">Metallic / Test</td></tr>
                        <tr>
                            <td><strong>Cu - Zn (Brass)</strong></td>
                            <td class="val-mono">-0.10</td>
                            <td><span class="type-tag text-ordering">Ordering</span></td>
                            <td>Prefer A-B neighbors (Intermetallics).</td>
                        </tr>
                        <tr>
                            <td><strong>Au - Cu</strong></td>
                            <td class="val-mono">-0.08</td>
                            <td><span class="type-tag text-ordering">Ordering</span></td>
                            <td>Forms ordered compounds.</td>
                        </tr>
                        <tr>
                            <td><strong>Simulation Test</strong></td>
                            <td class="val-mono">-0.15</td>
                            <td><span class="type-tag text-ordering">Strong Ordering</span></td>
                            <td>Use to see "box-like" profiles.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="help-section">
            <h2 class="help-title"><span class="step-badge">7</span> Advanced Topics & Limits</h2>
            
            <div class="theory-box">
                <p>
                    This solver implements vacancy-mediated Onsager diffusion using a 
                    simplified physical model. Limitations include:
                </p>
                <ul style="margin-top:10px; padding-left:20px; color:var(--text-muted); font-size:14px;">
                    <li><strong>1D geometry:</strong> The system is a one-dimensional slab.</li>
                    <li><strong>Constant prefactors:</strong> $D_0$ and $Q$ are concentration-independent.</li>
                    <li><strong>No defect chemistry:</strong> Charged vacancies or Frenkel pairs are not explicitly tracked.</li>
                    <li><strong>Single Crystal:</strong> No grain boundaries or dislocations.</li>
                </ul>
                <p style="margin-top:10px;">
                    Even with these simplifications, the solver reproduces Kirkendall shifts, 
                    uphill diffusion, vacancy wind, and interface sharpening.
                </p>
            </div>
        </div>

        <div class="help-section">
            <h2 class="help-title"><span class="step-badge">8</span> Notes & References</h2>
            
            <div style="background:#f1f5f9; padding:20px; border-radius:8px; font-size:13px; color:var(--text-muted);">
                <p><strong>Usage:</strong> Intended for teaching, research, and rapid prototyping.</p>
                <p><strong>Citation:</strong> If used in academic work, please cite "Onsager Multicomponent Diffusion Solver v8.4, 2025" and the Manning-Darken coupling expressions.</p>
                <p><strong>Tech Stack:</strong> WebWorker for physics engine, Chart.js (2D), Plotly (3D).</p>
            </div>
        </div>

    </div>
</div>

            
        </main>
    </div>

    <template id="elementTemplate">
        <div class="element-card">
            <input type="hidden" class="el-color">
            <button class="delete-btn" title="Remove"><i class="fas fa-times"></i></button>
            
            <div class="element-grid">
                <div class="input-group grid-full">
                    <label>Dopant</label>
                    <select class="el-name" onchange="updateElementParams(this)"></select>
                </div>
                <div class="input-group">
                    <label>D*₀</label>
                    <input type="text" class="el-d0" onchange="debouncedUpdate()">
                </div>
                <div class="input-group">
                    <label>Q (eV)</label>
                    <input type="number" class="el-q" step="0.1" onchange="debouncedUpdate()">
                </div>
                <div class="input-group">
                    <label style="color: var(--danger)">Ω (eV)</label>
                    <input type="number" class="el-omega" value="0" step="0.01" onchange="debouncedUpdate()" style="background:#fff1f2; color:#9f1239; font-weight:bold;">
                </div>
                <div class="input-group">
                    <label>Source %</label>
                    <input type="number" class="el-c-left" min="0" max="100" onchange="debouncedUpdate()">
                </div>
                <div class="input-group">
                    <label>Matrix %</label>
                    <input type="number" class="el-c-right" min="0" max="100" onchange="debouncedUpdate()">
                </div>
            </div>
        </div>
    </template>

<script id="worker-code" type="javascript/worker">
    const KB_EV = 8.617333262145e-5; 

    self.onmessage = function(e) {
        const inputs = e.data;
        try {
            const Temp = inputs.temp;
            const kBT = KB_EV * Temp;
            const Time_s = inputs.timeHours * 3600;
            const N = inputs.N;
            const L_m = inputs.totalLength * 1e-6; 
            const Source_m = inputs.sourceLength * 1e-6;
            const dx = L_m / (N - 1);
            
            const interfaceNode = Math.round(Source_m / dx);
            const matExp = -inputs.targetQ / (kBT);
            const D_star_matrix = inputs.targetD0 * Math.exp(matExp);

            const species = inputs.elements.map(el => {
                const exp = -el.q / (kBT);
                const D_star = el.d0 * Math.exp(exp);
                const C = new Float64Array(N);
                for(let i=0; i<N; i++) C[i] = (i < interfaceNode) ? el.cLeft / 100 : el.cRight / 100;

                return { ...el, D_star, omega: el.omega || 0, C, C_new: new Float64Array(N), Flux: new Float64Array(N), history: [], fluxHistory: [] };
            });

            let maxD_initial = getSpectralRadius(species, D_star_matrix, N);
            let dt = (0.4 * dx * dx) / maxD_initial;
            let current_time = 0;
            let step = 0;
            const estimatedSteps = Math.ceil(Time_s / dt);
            const saveInterval = Math.max(1, Math.floor(estimatedSteps / 40)); 
            const reportInterval = Math.max(100, Math.floor(estimatedSteps / 50));

            while (current_time < Time_s) {
                if (step % 100 === 0) {
                    const maxEigenvalue = getSpectralRadius(species, D_star_matrix, N);
                    dt = (0.4 * dx * dx) / maxEigenvalue;
                }
                if (current_time + dt > Time_s) dt = Time_s - current_time;

                for (let i = 0; i < N - 1; i++) {
                    const C_local = species.map(s => (s.C[i] + s.C[i+1]) / 2);
                    const grads = species.map(s => (s.C[i+1] - s.C[i]) / dx);
                    
                    species.forEach((s_i, idx_i) => {
                        let flux_onsager = 0;
                        species.forEach((s_j, idx_j) => {
                            let D_ij = 0;
                            if (idx_i === idx_j) D_ij = s_i.D_star + C_local[idx_i] * (D_star_matrix - s_i.D_star);
                            else D_ij = C_local[idx_i] * (D_star_matrix - s_j.D_star);
                            flux_onsager += -1 * D_ij * grads[idx_j];
                        });
                        const conc = C_local[idx_i];
                        const term = (2 * s_i.omega * conc * (1 - conc)) / kBT;
                        const Phi = 1 - term;
                        s_i.Flux[i] = flux_onsager * Phi;
                    });
                }

                for (let i = 1; i < N - 1; i++) {
                    species.forEach(s => {
                        const dJ_dx = (s.Flux[i] - s.Flux[i-1]) / dx;
                        s.C_new[i] = s.C[i] - dt * dJ_dx;
                    });
                }
                species.forEach(s => { s.C_new[0] = s.C_new[1]; s.C_new[N-1] = s.C_new[N-2]; });

                species.forEach(s => {
                    const temp = s.C; s.C = s.C_new; s.C_new = temp;
                    if (inputs.mode === 'history' && step % saveInterval === 0) {
                        s.history.push(Float64Array.from(s.C));
                        s.fluxHistory.push(Float64Array.from(s.Flux));
                    }
                });

                current_time += dt;
                step++;
                if (step % reportInterval === 0) {
                    self.postMessage({ type: 'progress', percent: Math.min(100, Math.round((current_time / Time_s) * 100)) });
                }
            }

            const finalMatrix = new Float64Array(N);
            for(let i=0; i<N; i++) {
                let sum = 0;
                species.forEach(s => sum += s.C[i]);
                finalMatrix[i] = Math.max(0, 1 - sum);
            }

            self.postMessage({ type: 'complete', species, matrix: finalMatrix, dx, interfaceX: Source_m });
        } catch (err) {
            self.postMessage({ type: 'error', message: err.message });
        }
    };

    function getSpectralRadius(species, D_star_matrix, N) {
        let maxEigenvalue = 0;
        for (let x = 0; x < N; x++) {
            for (let i = 0; i < species.length; i++) {
                let rowSum = 0;
                const C_i = species[i].C[x];
                for (let j = 0; j < species.length; j++) {
                    let D_ij = 0;
                    if (i === j) D_ij = species[i].D_star + C_i * (D_star_matrix - species[i].D_star);
                    else D_ij = C_i * (D_star_matrix - species[j].D_star);
                    rowSum += Math.abs(D_ij);
                }
                let phi_est = 1.0;
                if (species[i].omega !== 0) phi_est = Math.max(1, Math.abs(1 - (2 * species[i].omega * 0.25) / (8.617e-5 * 2000))); 
                if (rowSum * phi_est > maxEigenvalue) maxEigenvalue = rowSum * phi_est;
            }
        }
        return Math.max(maxEigenvalue, 1e-35);
    }
</script>

<script>
    let worker = null;
    let chartInstance = null;
    let currentTab = 'profile';
    let debounceTimer;
    let lastResults = null;
    let lastInputs = null;

    const CATION_DB = {
        "Sc": { label: "Sc³⁺ (Scandium)",   d0: "4.0e-10", q: 1.6 },
        "Ti": { label: "Ti⁴⁺ (Titanium)",   d0: "8.0e-10", q: 1.5 },
        "V":  { label: "V³⁺ (Vanadium)",    d0: "6.0e-10", q: 1.6 },
        "Cr": { label: "Cr³⁺ (Chromium)",   d0: "3.5e-10", q: 1.7 },
        "Mn": { label: "Mn²⁺ (Manganese)",  d0: "1.5e-10", q: 1.8 },
        "Fe": { label: "Fe²⁺ (Iron)",       d0: "1.2e-9",  q: 1.6 },
        "Co": { label: "Co²⁺ (Cobalt)",     d0: "5.0e-10", q: 1.7 },
        "Ni": { label: "Ni²⁺ (Nickel)",     d0: "2.5e-10", q: 1.8 },
        "Cu": { label: "Cu²⁺ (Copper)",     d0: "3.0e-10", q: 1.7 },
        "Zn": { label: "Zn²⁺ (Zinc)",       d0: "8.0e-10", q: 1.6 }
    };

    function createWorker() {
        const blob = new Blob([document.getElementById('worker-code').textContent], {type: "text/javascript"});
        return new Worker(window.URL.createObjectURL(blob));
    }

    function terminateWorker() {
        if (worker) { worker.terminate(); worker = null; updateStatus(0, "Stopped"); }
    }

    function updateStatus(percent, text) {
        const area = document.getElementById('status-area');
        const bar = document.getElementById('header-progress');
        const lbl = document.getElementById('header-status');
        if(text === 'Ready') { area.style.opacity = '0'; } 
        else { area.style.opacity = '1'; bar.style.width = percent + '%'; lbl.innerText = text || (percent + '%'); }
    }

    function triggerCalculation() {
        const inputs = validateInputs();
        if(!inputs) return;
        terminateWorker();
        
        inputs.mode = (currentTab === 'time3d' || currentTab === 'flux') ? 'history' : 'snapshot';
        
        worker = createWorker();
        worker.onmessage = function(e) {
            const msg = e.data;
            if (msg.type === 'progress') { updateStatus(msg.percent, msg.percent + '%'); } 
            else if (msg.type === 'complete') {
                updateStatus(100, 'Done');
                setTimeout(() => updateStatus(0, 'Ready'), 1000);
                renderResults(msg, inputs);
                worker.terminate();
            } else if (msg.type === 'error') { console.error(msg.message); updateStatus(0, 'Error'); }
        };
        updateStatus(0, 'Calculating');
        worker.postMessage(inputs);
    }

    function renderResults(res, inputs) {
        lastResults = res;
        lastInputs = inputs;

        if (currentTab === 'profile') {
            const dx = res.dx * 1e6;
            const labels = Array.from({length: inputs.N}, (_, i) => (i * dx).toFixed(2));
            
            const datasets = res.species.map(s => ({
                label: s.fullLabel,
                data: Array.from(s.C).map(v => v * 100),
                borderColor: s.color, backgroundColor: s.color + '20',
                borderWidth: 2, pointRadius: 0, fill: true,
                cubicInterpolationMode: 'monotone', tension: 0.4
            }));
            
            datasets.unshift({
                label: 'MgO Matrix',
                data: Array.from(res.matrix).map(v => v * 100),
                borderColor: '#6366f1', borderWidth: 2, borderDash: [5,5], 
                pointRadius: 0, fill: false, cubicInterpolationMode: 'monotone', tension: 0.4
            });
            
            const interfaceXVal = res.interfaceX * 1e6;
            datasets.push({
                label: 'Orig. Interface',
                borderColor: '#64748b', borderWidth: 2, borderDash: [6, 4], 
                pointRadius: 0, fill: false, showLine: true, type: 'scatter',
                data: [{x: interfaceXVal, y: 0}, {x: interfaceXVal, y: 100}]
            });

            if(chartInstance) chartInstance.destroy();

            chartInstance = new Chart(document.getElementById('diffusionChart'), {
                type: 'line', data: { labels, datasets },
                options: { 
                    responsive: true, maintainAspectRatio: false, animation: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: { 
                        x: { type: 'linear', min: 0, max: inputs.totalLength, title: {display:true, text:'Depth (µm)'} },
                        y: { min: 0, max: 100, title: {display:true, text:'Concentration (%)'} }
                    }
                }
            });

        } else if (currentTab === 'flux') {
            const xData = Array.from({length: inputs.N}, (_, i) => i * (res.dx * 1e6));
            const traces = res.species.map(s => {
                const zData = s.fluxHistory.map(row => Array.from(row));
                const yData = Array.from({length: zData.length}, (_, i) => i * (inputs.timeHours/zData.length));
                return {
                    type: 'surface', x: xData, y: yData, z: zData,
                    name: s.name, showscale: false, showlegend: true, opacity: 0.9,
                    colorscale: [ [0, '#ffffff'], [1, s.color] ]
                };
            });
            Plotly.newPlot('plotly-flux', traces, {
                margin: {l:0,r:0,b:0,t:30}, showlegend: true, legend: { x: 0, y: 1 },
                scene: { xaxis:{title:'Depth (µm)'}, yaxis:{title:'Time (h)'}, zaxis:{title:'Flux (J)'}, aspectmode: 'cube',camera: { eye: { x: 1.5, y: 1.5, z: 1.3 } } }
            });

        } else if (currentTab === 'time3d') {
            const xData = Array.from({length: inputs.N}, (_, i) => i * (res.dx * 1e6));
            const traces = res.species.map(s => {
                const zData = s.history.map(row => Array.from(row).map(v => v*100));
                const yData = Array.from({length: zData.length}, (_, i) => i * (inputs.timeHours/zData.length));
                return {
                    type: 'surface', x: xData, y: yData, z: zData,
                    name: s.name, showscale: false, showlegend: true, opacity: 0.8,
                    colorscale: [ [0, '#ffffff'], [1, s.color] ]
                };
            });
            Plotly.newPlot('plotly-time', traces, {
                margin: {l:0,r:0,b:0,t:30}, showlegend: true, legend: { x: 0, y: 1 },
                scene: { xaxis:{title:'Depth (µm)'}, yaxis:{title:'Time (h)'}, zaxis:{title:'Conc (%)'}, aspectmode: 'cube',camera: { eye: { x: 1.5, y: 1.5, z: 1.3 } } }
            });
        }
    }

    function downloadData() {
        if (!lastResults || !lastInputs) { alert("No data to download."); return; }
        let csvContent = "data:text/csv;charset=utf-8,";
        csvContent += "--- SIMULATION PARAMETERS ---\n";
        csvContent += `Temperature (K),${lastInputs.temp}\nTime (Hours),${lastInputs.timeHours}\nSource Length (um),${lastInputs.sourceLength}\nTotal Length (um),${lastInputs.totalLength}\nMatrix D0 (m2/s),${lastInputs.targetD0}\nMatrix Q (eV),${lastInputs.targetQ}\nGrid Points,${lastInputs.N}\n\n`;
        csvContent += "--- SPECIES INFO ---\nName,D0,Q,Omega (eV),C_Source (%),C_Matrix (%)\n";
        lastInputs.elements.forEach(el => { csvContent += `${el.name},${el.d0},${el.q},${el.omega},${el.cLeft},${el.cRight}\n`; });
        csvContent += "\n--- CALCULATION RESULTS ---\n";
        let headerRow = ["Depth (um)", "Matrix Conc (%)"];
        lastResults.species.forEach(s => { headerRow.push(`${s.name} Conc (%)`); headerRow.push(`${s.name} Flux (J)`); });
        csvContent += headerRow.join(",") + "\n";
        const N = lastInputs.N;
        const dx_um = lastResults.dx * 1e6;
        for (let i = 0; i < N; i++) {
            let row = [];
            row.push((i * dx_um).toFixed(4));
            row.push((lastResults.matrix[i] * 100).toFixed(4));
            lastResults.species.forEach(s => { row.push((s.C[i] * 100).toFixed(4)); row.push((s.Flux[i]).toExponential(4)); });
            csvContent += row.join(",") + "\n";
        }
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", `onsager_diffusion_v8.4.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function validateInputs() {
        const elements = [];
        document.querySelectorAll('.element-card').forEach(card => {
            const nameSelect = card.querySelector('.el-name');
            elements.push({
                name: nameSelect.options[nameSelect.selectedIndex]?.text.split(' ')[0] || "Unk",
                fullLabel: nameSelect.options[nameSelect.selectedIndex]?.text || "Unknown",
                d0: parseFloat(card.querySelector('.el-d0').value), 
                q: parseFloat(card.querySelector('.el-q').value),
                omega: parseFloat(card.querySelector('.el-omega').value) || 0,
                cLeft: parseFloat(card.querySelector('.el-c-left').value),
                cRight: parseFloat(card.querySelector('.el-c-right').value),
                color: card.querySelector('.el-color').value
            });
        });
        if (elements.length === 0) return null;
        const src = parseFloat(document.getElementById('sourceLength').value);
        const tot = parseFloat(document.getElementById('totalLength').value);
        if(src >= tot) { alert("Source length must be smaller than Total length"); return null; }
        return {
            temp: parseFloat(document.getElementById('temp').value),
            timeHours: parseFloat(document.getElementById('time').value),
            sourceLength: src, totalLength: tot,
            N: parseInt(document.getElementById('gridPoints').value),
            targetD0: parseFloat(document.getElementById('targetD0').value),
            targetQ: parseFloat(document.getElementById('targetQ').value),
            elements
        };
    }

    function debouncedUpdate() { clearTimeout(debounceTimer); debounceTimer = setTimeout(triggerCalculation, 600); }
    function switchTab(tab) {
        currentTab = tab;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.getElementById('tab-' + tab).classList.add('active');
        document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
        document.getElementById('pane-' + tab).classList.add('active');
        if(tab === 'time3d' || tab === 'flux') window.dispatchEvent(new Event('resize'));
        if(tab !== 'help') triggerCalculation();
    }

    function addElement(initialKey = null) {
        const list = document.getElementById('elementsList');
        if (list.children.length >= 4) { alert("Max 4 dopants"); return; }
        const template = document.getElementById('elementTemplate');
        const clone = template.content.cloneNode(true);
        const card = clone.querySelector('.element-card');
        const color = ['#ef4444', '#10b981', '#f59e0b', '#8b5cf6'][list.children.length % 4];
        card.style.borderLeftColor = color;
        clone.querySelector('.el-color').value = color;
        const select = clone.querySelector('.el-name');
        const keys = Object.keys(CATION_DB);
        keys.forEach(k => { const opt = document.createElement('option'); opt.value = k; opt.text = CATION_DB[k].label; select.appendChild(opt); });
        const selectedKey = initialKey || keys[0]; 
        select.value = selectedKey;
        const data = CATION_DB[selectedKey];
        clone.querySelector('.el-d0').value = data.d0;
        clone.querySelector('.el-q').value = data.q;
        clone.querySelector('.el-c-left').value = 25; 
        clone.querySelector('.el-c-right').value = 0;
        clone.querySelector('.delete-btn').onclick = (e) => { e.target.closest('.element-card').remove(); debouncedUpdate(); };
        list.appendChild(clone);
        if(!initialKey) debouncedUpdate();
    }

    function updateElementParams(select) {
        const data = CATION_DB[select.value];
        const card = select.closest('.element-card');
        card.querySelector('.el-d0').value = data.d0;
        card.querySelector('.el-q').value = data.q;
        debouncedUpdate();
    }

    window.onload = function() { addElement("Ni"); setTimeout(triggerCalculation, 100); };
</script>

</body>
</html>