<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Onsager Diffusion v8.5</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    
    <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
<style>
    /* --- 1. Variables & Reset --- */
    :root {
        --bg-app: #f1f5f9;       
        --bg-panel: #ffffff;
        --border: #e2e8f0;       
        --text-main: #0f172a;    
        --text-muted: #64748b;   
        --primary: #ea580c;      
        --primary-light: #fff7ed;
        --accent: #4f46e5;       
        --accent-light: #eef2ff; 
        --danger: #ef4444;
        --success: #10b981;
        --warning-bg: #fffbeb;
        --warning-border: #f59e0b;
    }

    * { box-sizing: border-box; }

    body {
        margin: 0; padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        background-color: var(--bg-app);
        color: var(--text-main);
        height: 100vh;
        display: flex; flex-direction: column; overflow: hidden;
    }

    /* --- 2. App Header --- */
    .app-header {
        height: 56px; background: var(--bg-panel); border-bottom: 1px solid var(--border);
        display: flex; align-items: center; justify-content: space-between;
        padding: 0 16px; box-shadow: 0 1px 2px rgba(0,0,0,0.05); z-index: 10; flex-shrink: 0;
    }

    .brand { display: flex; align-items: center; gap: 12px; }
    .brand-icon {
        width: 32px; height: 32px; background-color: var(--primary); color: white;
        border-radius: 6px; display: flex; align-items: center; justify-content: center;
    }
    .brand h1 { font-size: 18px; margin: 0; font-weight: 700; color: var(--text-main); }
    .brand span { font-size: 12px; font-weight: 400; color: var(--text-muted); margin-left: 5px; }

    /* Status Bar */
    .status-area {
        flex: 1; margin: 0 32px; display: flex; align-items: center; gap: 12px;
        opacity: 0; transition: opacity 0.3s;
    }
    .progress-track {
        flex: 1; height: 6px; background: var(--bg-app); border-radius: 10px; overflow: hidden;
    }
    .progress-bar {
        height: 100%; background: var(--primary); width: 0%; transition: width 0.2s;
    }
    .status-text { 
        font-family: "Menlo", "Consolas", monospace; font-size: 12px; 
        color: var(--text-muted); min-width: 60px; text-align: right; 
    }
    .stop-btn { border: none; background: none; color: var(--danger); cursor: pointer; font-size: 14px; }

    /* Navigation Tabs */
    .nav-tabs { display: flex; height: 100%; gap: 4px; }
    .tab-btn {
        background: none; border: none; height: 100%; padding: 0 16px;
        color: var(--text-muted); font-weight: 600; font-size: 13px; cursor: pointer;
        border-bottom: 2px solid transparent; transition: all 0.2s;
        display: flex; align-items: center; gap: 8px;
    }
    .tab-btn:hover { background-color: var(--bg-app); color: var(--text-main); }
    .tab-btn.active {
        background-color: var(--accent-light); color: var(--accent); border-bottom-color: var(--accent);
    }
    .tab-btn.help-btn { color: #059669; }

    /* --- 3. Layout --- */
    .main-container {
        display: flex; flex: 1; overflow: hidden; position: relative;
    }

    /* Sidebar */
    .sidebar {
        width: 320px; background: var(--bg-panel); border-right: 1px solid var(--border);
        overflow-y: auto; display: flex; flex-direction: column; padding: 16px; gap: 20px;
        flex-shrink: 0; box-shadow: 4px 0 24px rgba(0,0,0,0.02); z-index: 5;
    }

    .control-panel {
        border: 1px solid var(--border); border-radius: 8px; padding: 12px; background: #fafafa;
    }
    .panel-orange { background: var(--primary-light); border-color: #fed7aa; }
    .panel-indigo { background: var(--accent-light); border-color: #c7d2fe; }
    
    .panel-header {
        display: flex; align-items: center; gap: 8px; margin-bottom: 12px;
        border-bottom: 1px solid rgba(0,0,0,0.06); padding-bottom: 8px;
    }
    .panel-title {
        font-size: 11px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.5px; margin: 0;
        color: var(--text-muted);
    }
    .text-orange { color: #9a3412; }
    .text-indigo { color: #3730a3; }

    /* Inputs */
    .input-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .col-span-2 { grid-column: span 2; }
    
    .input-group label {
        display: block; font-size: 10px; font-weight: 700; margin-bottom: 4px; color: var(--text-muted);
    }
    .input-group input, .input-group select {
        width: 100%; padding: 6px 8px; font-size: 13px; border: 1px solid var(--border);
        border-radius: 4px; outline: none; background: white; color: var(--text-main);
        transition: border-color 0.2s;
    }
    .input-group input:focus { 
        border-color: var(--accent); box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1); 
    }

    /* Element Card */
    .element-card {
        background: white; border: 1px solid var(--border); border-left-width: 4px;
        border-radius: 6px; padding: 12px; margin-bottom: 10px; position: relative;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05); transition: transform 0.1s;
    }
    .element-card:hover { transform: translateY(-1px); box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05); }
    
    .element-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .grid-full { grid-column: 1 / -1; }
    
    .delete-btn {
        position: absolute; top: 6px; right: 6px; border: none; background: none; color: #cbd5e1;
        cursor: pointer; display: none; padding: 4px;
    }
    .element-card:hover .delete-btn { display: block; }
    .delete-btn:hover { color: var(--danger); }

    /* Buttons */
    .btn {
        border: none; border-radius: 6px; padding: 8px 12px; font-size: 11px; font-weight: 700;
        cursor: pointer; display: inline-flex; align-items: center; justify-content: center; gap: 6px;
        transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.5px;
    }
    .btn-add { background: var(--accent); color: white; float: right;}
    .btn-add:hover { background: #4338ca; }
    
    .btn-download { 
        width: 100%; background: white; border: 1px solid var(--border); color: var(--text-muted); margin-top: 16px; 
    }
    .btn-download:hover { background: #f8fafc; color: var(--text-main); border-color: #cbd5e1; }

    /* --- 4. Main Content Area & Charts --- */
    .content-area {
        flex: 1; background: var(--bg-app); position: relative; overflow: hidden;
    }
    .tab-pane {
        display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; overflow-y: auto;
    }
    .tab-pane.active { display: block; }

    .chart-wrapper {
        background: white; margin: 16px; border-radius: 12px; border: 1px solid var(--border);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05); height: calc(100% - 32px);
        padding: 16px; position: relative;
    }
    #plotly-flux, #plotly-time { width: 100%; height: 100%; }

    /* --- 5. Help Section (Redesigned) --- */
    .help-container {
        padding: 40px; max-width: 900px; margin: 0 auto; background: #ffffff;
        color: #334155; line-height: 1.6; min-height: 100%;
    }
    .help-header { margin-bottom: 40px; border-bottom: 2px solid #f1f5f9; padding-bottom: 20px; }
    .help-header h1 { font-size: 28px; color: #0f172a; font-weight: 700; margin: 0 0 8px 0; }
    .theory-box {
        background: #fff; border-left: 4px solid #cbd5e1; padding: 20px; margin: 24px 0;
        border-radius: 0 8px 8px 0; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
    }
    .theory-box h4 { 
        margin: 0 0 10px 0; color: #334155; font-size: 13px; font-weight: 800; text-transform: uppercase; 
    }
    .box-warning { border-left-color: var(--warning-border); background: var(--warning-bg); }
    .box-info    { border-left-color: #3b82f6; background: #eff6ff; }
    
    .param-table {
        width: 100%; border-collapse: collapse; font-size: 14px; margin: 20px 0;
    }
    .param-table th { background: #f1f5f9; padding: 10px; text-align: left; font-weight: 700; border-bottom: 2px solid #e2e8f0; }
    .param-table td { padding: 10px; border-bottom: 1px solid #e2e8f0; }
    .param-table tr:last-child td { border: none; }
    .tag { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 700; background: #e2e8f0; color: #475569; }
    .tag-blue { background: #dbeafe; color: #1e40af; }
    .tag-orange { background: #ffedd5; color: #9a3412; }

    /* Scrollbars */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
</style>

</head>
<body>

    <header class="app-header">
        <div class="brand">
            <div class="brand-icon"><i class="fas fa-project-diagram"></i></div>
            <div><h1>Onsager Diffusion <span>8.5</span></h1></div>
        </div>
        
        <div id="status-area" class="status-area">
            <div class="progress-track"><div id="header-progress" class="progress-bar"></div></div>
            <span id="header-status" class="status-text">Calculating...</span>
            <button onclick="terminateWorker()" class="stop-btn" title="Stop"><i class="fas fa-stop"></i></button>
        </div>

        <nav class="nav-tabs">
            <button onclick="switchTab('profile')" id="tab-profile" class="tab-btn active"><i class="fas fa-chart-line"></i> Profile</button>
            <button onclick="switchTab('flux')" id="tab-flux" class="tab-btn"><i class="fas fa-water"></i> 3D Flux</button>
            <button onclick="switchTab('time3d')" id="tab-time3d" class="tab-btn"><i class="fas fa-cube"></i> 3D Conc</button>
            <button onclick="switchTab('help')" id="tab-help" class="tab-btn help-btn"><i class="fas fa-info-circle"></i> Theory</button>
        </nav>
    </header>

    <div class="main-container">
        
        <aside class="sidebar">
            <div class="control-panel panel-orange">
                <div class="panel-header text-orange">
                    <i class="fas fa-ruler-combined"></i>
                    <h3 class="panel-title">1. Geometry</h3>
                </div>
                <div class="input-grid">
                    <div class="input-group">
                        <label>Source Length (µm)</label>
                        <input type="number" id="sourceLength" value="5" min="0.1" step="0.1" onchange="debouncedUpdate()">
                    </div>
                    <div class="input-group">
                        <label>Total Length (µm)</label>
                        <input type="number" id="totalLength" value="20" min="1" step="1" onchange="debouncedUpdate()">
                    </div>
                    <div class="input-group col-span-2">
                        <label>Grid Points</label>
                        <input type="number" id="gridPoints" value="100" min="50" max="400" onchange="debouncedUpdate()">
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <div class="panel-header">
                    <h3 class="panel-title">2. Conditions</h3>
                </div>
                <div class="input-grid">
                    <div class="input-group">
                        <label>Temp (K)</label>
                        <input type="number" id="temp" value="1250" min="600" max="2800" onchange="debouncedUpdate()">
                    </div>
                    <div class="input-group">
                        <label>Time (Hours)</label>
                        <input type="number" id="time" value="24" min="0.1" step="0.1" onchange="debouncedUpdate()">
                    </div>
                </div>
            </div>

            <div class="control-panel panel-indigo">
                <div class="panel-header text-indigo">
                    <h3 class="panel-title">3. Interaction Matrices</h3>
                </div>
                <div class="input-grid">
                    <div class="input-group col-span-2">
                        <label>Matrix D₀ (m²/s)</label>
                        <input type="text" id="targetD0" value="5.0e-11" onchange="debouncedUpdate()">
                    </div>
                    <div class="input-group col-span-2">
                        <button onclick="openInteractionModal()" class="btn" style="width:100%; background:white; border:1px solid #c7d2fe; color:#3730a3;">
                            <i class="fas fa-project-diagram"></i> Edit Q & Ω Matrices
                        </button>
                    </div>
                </div>
            </div>

            <div style="margin-top:auto;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h3 class="panel-title">4. Dopants</h3>
                    <button onclick="addElement()" class="btn btn-add"><i class="fas fa-plus"></i> ADD</button>
                </div>
                <div id="elementsList"></div>
                <button onclick="downloadData()" class="btn btn-download"><i class="fas fa-download"></i> Download CSV</button>
            </div>
        </aside>

        <main class="content-area">
            
            <div id="pane-profile" class="tab-pane active">
                <div class="chart-wrapper"><canvas id="diffusionChart"></canvas></div>
            </div>

            <div id="pane-flux" class="tab-pane">
                 <div class="chart-wrapper"><div id="plotly-flux"></div></div>
            </div>

            <div id="pane-time3d" class="tab-pane">
                 <div class="chart-wrapper"><div id="plotly-time"></div></div>
            </div>

<div id="pane-help" class="tab-pane">
    <div class="help-container">

        <div class="help-header">
            <h1>Theory & Documentation</h1>
            <p>Onsager Multi-Component Diffusion Solver • v8.5</p>
        </div>

        <div class="help-section">
            <h2 class="help-title">1. Overview</h2>
            <p>
                This software simulates <strong>multi-component cation diffusion</strong> in oxide crystals (e.g., Rock-salt structures like MgO, NiO). 
                While standard introductory models (Fick's Laws) assume atoms move independently, real solid-state systems imply 
                <strong>correlations</strong>. Atoms share a common lattice and compete for the same vacancies.
            </p>
            <p>
                This solver uses the <strong>Onsager Matrix Formalism</strong> to account for these cross-interactions, calculating phenomena 
                that simpler models miss, such as <em>Uphill Diffusion</em>, <em>Vacancy Wind</em>, and <em>Kinetic Demixing</em>.
            </p>
        </div>

        <div class="help-section">
            <h2 class="help-title">2. Physical Models</h2>

            <div class="theory-box">
                <h4>2.1 The Onsager Flux Equation (General)</h4>
                <p>
                    In a multi-component system, the flux of species $i$ ($J_i$) is driven by the gradients of chemical potential of 
                    <strong>all</strong> species present. In this solver, we express this via a diffusion matrix:
                </p>
                <div class="math-block">$$ J_i = -\sum_j D_{ij} \nabla C_j $$</div>
                <ul>
                    <li><strong>Diagonal Terms ($D_{ii}$):</strong> The standard diffusion of species $i$ down its own gradient.</li>
                    <li><strong>Off-Diagonal Terms ($D_{ij}$):</strong> Cross-coefficients. For example, a gradient in Ni ($j$) can cause a flux of Mg ($i$) due to vacancy coupling.</li>
                </ul>
            </div>

            <div class="theory-box box-info">
                <h4>2.2 The Vacancy Wind Effect</h4>
                <p>
                    Diffusion in these oxides occurs via a <strong>Vacancy Mechanism</strong>. 
                    If a fast species (e.g., Zn) diffuses rapidly in one direction ($+x$), there is a net flow of vacancies in the opposite direction ($-x$).
                    This "wind" of vacancies impinges on slower species (e.g., Mg), potentially dragging them <strong>up</strong> their concentration gradient.
                    <br><br>
                    <em>In this simulation, this is automatically calculated via the off-diagonal kinetic terms.</em>
                </p>
            </div>

            <div class="theory-box" style="border-left-color: #8b5cf6; background: #f5f3ff;">
                <h4 style="color: #5b21b6;">2.3 The Manning-Darken Connection</h4>
                <p>
                    Users often ask how this relates to the classic <strong>Darken</strong> equation. 
                    The Darken equation describes interdiffusion in a binary alloy, relating the chemical diffusion coefficient ($\tilde{D}$) 
                    to the tracer diffusivities ($D^*$) of the individual components.
                </p>
                <p><strong>The Classic Darken Equation:</strong></p>
                <div class="math-block">
                    $$ \tilde{D} = (X_A D^*_B + X_B D^*_A) \cdot \Phi $$
                </div>
                <p>
                    Where $X$ is mole fraction and $\Phi$ is the thermodynamic factor. However, Darken ignored the vacancy wind. 
                    <strong>Manning</strong> refined this by introducing a correlation factor ($S$):
                </p>
                <p><strong>The Manning Correction:</strong></p>
                <div class="math-block">
                    $$ \tilde{D}_{Manning} = \left( X_A D^*_B + X_B D^*_A + 2 X_A X_B (D^*_A - D^*_B)^2 / M_0 \right) \cdot \Phi $$
                </div>
                <p>
                    <strong>How this solver works:</strong><br>
                    This tool solves the full Onsager matrix. In the limit of a binary system, our results are mathematically equivalent to the Manning formulation. 
                    We calculate the fluxes $J_i$ individually rather than lumping them into a single $\tilde{D}$, allowing us to simulate $N > 2$ components 
                    where a single "Interdiffusion Coefficient" cannot be defined.
                </p>
            </div>
        </div>

        <div class="help-section">
            <h2 class="help-title">3. The Simulation Matrices</h2>
            <p>
                To predict diffusion profiles, we separate the problem into <strong>Kinetics</strong> (Barrier Heights) and <strong>Thermodynamics</strong> (Mixing Energy).
            </p>

            <div class="theory-box" style="border-left-color: #ea580c; background: #fff7ed;">
                <h4 style="color: #9a3412;">3.1 Kinetics: The Q-Matrix ($Q_{ij}$)</h4>
                <p>
                    <strong>Definition:</strong> $Q_{ij}$ represents the activation energy (barrier) for species $i$ to jump when its local environment is dominated by species $j$.
                </p>
                <p>The solver calculates a local diffusion coefficient $D^*_i(x)$ at every grid point:</p>
                <div class="math-block">
                    $$ D_i^*(x) = D_{0,i} \exp\left(-\frac{\sum_j C_j(x) Q_{ij}}{k_B T}\right) $$
                </div>
                <ul>
                    <li>If $Q_{Mg-Mg} < Q_{Mg-Ni}$, Mg diffuses slower as the Ni concentration increases (trapping).</li>
                    <li>This allows the simulation of "sluggish diffusion" in high-entropy zones or doped regions.</li>
                </ul>
            </div>

            <div class="theory-box" style="border-left-color: #db2777; background: #fdf2f8;">
                <h4 style="color: #be185d;">3.2 Thermodynamics: The $\Omega$-Matrix ($\Omega_{ij}$)</h4>
                <p>
                    <strong>Definition:</strong> This captures the Enthalpy of Mixing ($H_{mix}$) using a Regular Solution Model.
                    It defines the "Thermodynamic Factor" $\Phi$ found in the Darken/Manning equations.
                </p>
                <div class="math-block">
                     H_{mix} = \sum_{i \neq j} \Omega_{ij} X_i X_j
                </div>
                <table class="param-table" style="margin-top:10px;">
                    <tr>
                        <td><strong>$\Omega > 0$</strong></td>
                        <td><strong>Repulsive / Phase Separating.</strong> Species dislike mixing. Increases driving force (pushing them apart). Can lead to spinodal decomposition.</td>
                    </tr>
                    <tr>
                        <td><strong>$\Omega = 0$</strong></td>
                        <td><strong>Ideal Solution.</strong> Mixing is driven purely by entropy (random walk).</td>
                    </tr>
                    <tr>
                        <td><strong>$\Omega < 0$</strong></td>
                        <td><strong>Ordering.</strong> Species attract. Reduces diffusion speed as atoms prefer to remain neighbors (short-range order).</td>
                    </tr>
                </table>
            </div>
        </div>

        <div class="help-section">
            <h2 class="help-title">4. Reference Parameter Values</h2>
            <p>
                The following defaults are used when selecting cations. They are based on general trends in MgO-based rock-salt oxides.
            </p>

            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:20px;">
                
                <div class="theory-box">
                    <h4>4.1 Self-Diffusion Data</h4>
                    <table class="param-table">
                        <thead>
                            <tr><th>Ion</th><th>$D_0$ (m²/s)</th><th>$Q$ (eV)</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><strong>Mg²⁺</strong></td><td>5.0e-11</td><td>2.20</td></tr>
                            <tr><td><strong>Ni²⁺</strong></td><td>2.5e-10</td><td>2.10</td></tr>
                            <tr><td><strong>Co²⁺</strong></td><td>5.0e-10</td><td>2.05</td></tr>
                            <tr><td><strong>Fe²⁺</strong></td><td>1.2e-9</td> <td>1.95</td></tr>
                            <tr><td><strong>Zn²⁺</strong></td><td>8.0e-10</td><td>1.85</td></tr>
                            <tr><td><strong>Cu²⁺</strong></td><td>3.0e-10</td><td>2.15</td></tr>
                            <tr><td><strong>Ca²⁺</strong></td><td>1.0e-10</td><td>2.60</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="theory-box box-warning">
                    <h4>4.2 Interaction parameters ($\Omega$)</h4>
                    <table class="param-table">
                        <thead>
                            <tr><th>Pair</th><th>$\Omega$ (eV)</th><th>Effect</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><strong>Mg-Ni</strong></td><td>0.02</td><td>Near Ideal</td></tr>
                            <tr><td><strong>Mg-Co</strong></td><td>0.03</td><td>Near Ideal</td></tr>
                            <tr><td><strong>Mg-Cu</strong></td><td>0.18</td><td>Strain (Jahn-Teller)</td></tr>
                            <tr><td><strong>Mg-Zn</strong></td><td>0.20</td><td>Coord. Mismatch</td></tr>
                            <tr><td><strong>Mg-Ca</strong></td><td>0.40</td><td>Size Mismatch</td></tr>
                            <tr><td><strong>Mg-Cr</strong></td><td>0.50</td><td>Charge Mismatch</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="help-section">
            <h2 class="help-title">5. Visualizing the Data</h2>
            <div class="viz-grid">
                <div class="viz-card">
                    <div class="viz-icon"><i class="fas fa-chart-line"></i></div>
                    <strong>Profile (2D)</strong>
                    <p>Standard Concentration vs. Depth. Look for "S-curves" vs "Error-function" shapes. Deviations imply concentration-dependent $D$.</p>
                </div>
                <div class="viz-card">
                    <div class="viz-icon"><i class="fas fa-water"></i></div>
                    <strong>Flux (3D)</strong>
                    <p>
                        <strong>Red Zones (Positive):</strong> Mass moving right.<br>
                        <strong>Blue Zones (Negative):</strong> Mass moving left.<br>
                        <em>Use this to spot vacancy wind effects where a species moves against its gradient.</em>
                    </p>
                </div>
                <div class="viz-card">
                    <div class="viz-icon"><i class="fas fa-cube"></i></div>
                    <strong>History (3D)</strong>
                    <p>Visualizes the evolution of concentration over time. Useful for observing transient "humps" at interfaces.</p>
                </div>
            </div>
        </div>

    </div>
</div>
        

        </main>
    </div>

    <template id="elementTemplate">
        <div class="element-card">
            <input type="hidden" class="el-color">
            <button class="delete-btn" title="Remove"><i class="fas fa-times"></i></button>
            <div class="element-grid">
                <div class="input-group grid-full">
                    <label>Dopant</label>
                    <select class="el-name" onchange="updateElementParams(this)"></select>
                </div>
                <div class="input-group">
                    <label>D*₀</label>
                    <input type="text" class="el-d0" onchange="debouncedUpdate()">
                </div>
                <div class="input-group">
                    <label>Source %</label>
                    <input type="number" class="el-c-left" min="0" max="100" onchange="debouncedUpdate()">
                </div>
                <div class="input-group">
                    <label>Matrix %</label>
                    <input type="number" class="el-c-right" min="0" max="100" onchange="debouncedUpdate()">
                </div>
            </div>
        </div>
    </template>


<div id="interaction-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:100; align-items:center; justify-content:center;">
  <div style="background:white; padding:0; border-radius:12px; max-width:900px; width:95%; max-height:90vh; display:flex; flex-direction:column; overflow:hidden; box-shadow:0 10px 25px rgba(0,0,0,0.2);">
    <div style="padding:20px; border-bottom:1px solid #e2e8f0; display:flex; justify-content:space-between; align-items:center; background:#f8fafc;">
      <div>
        <h2 style="margin:0; font-size:18px; font-weight:700; color:#0f172a;">Interaction Parameters</h2>
        <p style="margin:4px 0 0 0; font-size:12px; color:#64748b;">Kinetics (Q) and Thermodynamics (&#937;)</p>
      </div>
      <button onclick="closeInteractionModal()" style="border:none; background:none; font-size:20px; cursor:pointer; color:#64748b;"><i class="fas fa-times"></i></button>
    </div>

    <div style="flex:1; overflow-y:auto; padding:24px;">
      <div style="margin-bottom:30px;">
        <h3 style="font-size:14px; font-weight:700; color:#ea580c; margin-bottom:10px;">
          <i class="fas fa-tachometer-alt"></i> 1. KINETICS: Activation Energy $Q_{ij}$ (eV)
        </h3>
        <div style="overflow-x:auto;">
          <table id="q-matrix-table" style="width:100%; border-collapse:collapse; font-size:13px; border:1px solid #e2e8f0;"></table>
        </div>
      </div>

      <div>
        <h3 style="font-size:14px; font-weight:700; color:#db2777; margin-bottom:10px;">
          <i class="fas fa-magnet"></i> 2. THERMODYNAMICS: Interaction $\Omega_{ij}$ (eV)
        </h3>
        <div style="overflow-x:auto;">
          <table id="omega-matrix-table" style="width:100%; border-collapse:collapse; font-size:13px; border:1px solid #e2e8f0;"></table>
        </div>
      </div>
    </div>

    <div style="padding:16px 24px; border-top:1px solid #e2e8f0; text-align:right; background:#f8fafc;">
      <button onclick="closeInteractionModal()" class="btn" style="background:var(--primary); color:white; padding:10px 30px;">Apply Changes</button>
    </div>
  </div>
</div>

<script id="worker-code" type="javascript/worker">
    const KB_EV = 8.617333262145e-5; 

    self.onmessage = function(e) {
        const inputs = e.data;
        try {
            const Temp = inputs.temp;
            const kBT = KB_EV * Temp;
            const Time_s = inputs.timeHours * 3600;
            const N = inputs.N;
            const L_m = inputs.totalLength * 1e-6; 
            const Source_m = inputs.sourceLength * 1e-6;
            const dx = L_m / (N - 1);
            const interfaceNode = Math.round(Source_m / dx);
            
            // --- 1. SETUP ---
            const matrixD0 = inputs.targetD0;
            const matrixQVec = inputs.matrixQVector;
            const matrixOmegaVec = inputs.matrixOmegaVector;

            const species = inputs.elements.map(el => {
                const C = new Float64Array(N);
                for(let i=0; i<N; i++) C[i] = (i < interfaceNode) ? el.cLeft / 100 : el.cRight / 100;
                return { 
                    ...el,
                    D_star_map: new Float64Array(N),
                    C, C_new: new Float64Array(N), Flux: new Float64Array(N),
                    history: [], fluxHistory: [] 
                };
            });

            // --- 2. INITIALIZE ---
            updateDiffusivities(species, matrixD0, matrixQVec, N, kBT);

            // Time Step Estimation
            let globalMinQ = Math.min(...matrixQVec);
            species.forEach(s => globalMinQ = Math.min(globalMinQ, ...s.qVector));
            let maxD_est = Math.max(matrixD0, ...species.map(s=>s.d0)) * Math.exp(-globalMinQ/kBT);
            let dt = (0.4 * dx * dx) / maxD_est; 

            let current_time = 0;
            let step = 0;
            
            // FIX: Ensure a minimum number of saved frames regardless of speed
            const estimatedSteps = Math.ceil(Time_s / dt);
            const targetFrames = 40;
            const saveInterval = Math.max(1, Math.floor(estimatedSteps / targetFrames)); 
            const reportInterval = Math.max(100, Math.floor(estimatedSteps / 50));

            // --- 3. LOOP ---
            while (current_time < Time_s) {
                // ... Physics Update ...
                updateDiffusivities(species, matrixD0, matrixQVec, N, kBT);

                if (step % 1000 === 0) {
                     if (current_time + dt > Time_s) dt = Time_s - current_time;
                }

                // Onsager Fluxes
                for (let i = 0; i < N - 1; i++) {
                    const C_local = species.map(s => (s.C[i] + s.C[i+1]) / 2);
                    let sumC = 0; C_local.forEach(c => sumC += c);
                    const C_mat = 1.0 - sumC; 

                    let Q_mat_local = matrixQVec[0] * C_mat; 
                    species.forEach((s, idx) => { Q_mat_local += matrixQVec[idx+1] * C_local[idx]; });
                    const D_star_matrix_local = matrixD0 * Math.exp(-Q_mat_local / kBT);
                    const grads = species.map(s => (s.C[i+1] - s.C[i]) / dx);
                    
                    species.forEach((s_i, idx_i) => {
                        const D_star_i = (s_i.D_star_map[i] + s_i.D_star_map[i+1]) / 2;
                        let flux_onsager = 0;
                        species.forEach((s_j, idx_j) => {
                            let D_ij = 0;
                            if (idx_i === idx_j) D_ij = D_star_i + C_local[idx_i] * (D_star_matrix_local - D_star_i);
                            else {
                                const D_star_j = (s_j.D_star_map[i] + s_j.D_star_map[i+1]) / 2;
                                D_ij = C_local[idx_i] * (D_star_matrix_local - D_star_j);
                            }
                            flux_onsager += -1 * D_ij * grads[idx_j];
                        });
                        
                        // Thermo Factor
                        let interaction_sum = s_i.omegaVector[0] * C_mat;
                        species.forEach((s_n, idx_n) => { interaction_sum += s_i.omegaVector[idx_n + 1] * C_local[idx_n]; });
                        const thermo_term = (2 * interaction_sum * C_local[idx_i] * (1 - C_local[idx_i])) / kBT;
                        s_i.Flux[i] = flux_onsager * (1 - thermo_term);
                    });
                }

                // Update C
                for (let i = 1; i < N - 1; i++) {
                    species.forEach(s => {
                        const dJ_dx = (s.Flux[i] - s.Flux[i-1]) / dx;
                        s.C_new[i] = s.C[i] - dt * dJ_dx;
                    });
                }
                
                // Boundaries
                species.forEach(s => { s.C_new[0] = s.C_new[1]; s.C_new[N-1] = s.C_new[N-2]; });

                // Swap & Save
                species.forEach(s => {
                    const temp = s.C; s.C = s.C_new; s.C_new = temp;
                    // FIX: Always save if history mode, even if simulation is fast
                    if (inputs.mode === 'history' && (step % saveInterval === 0 || current_time + dt >= Time_s)) {
                        s.history.push(Float64Array.from(s.C));
                        s.fluxHistory.push(Float64Array.from(s.Flux));
                    }
                });

                current_time += dt;
                step++;
                
                if (step % reportInterval === 0) {
                    self.postMessage({ type: 'progress', percent: Math.min(100, Math.round((current_time / Time_s) * 100)) });
                }
            }

            // Cleanup & Final Matrix
            species.forEach(s => delete s.D_star_map);
            const finalMatrix = new Float64Array(N);
            for(let i=0; i<N; i++) {
                let sum = 0; species.forEach(s => sum += s.C[i]);
                finalMatrix[i] = Math.max(0, 1 - sum);
            }

            self.postMessage({ type: 'complete', species, matrix: finalMatrix, dx, interfaceX: Source_m });

        } catch (err) { self.postMessage({ type: 'error', message: err.message }); }
    };

    function updateDiffusivities(species, matrixD0, matrixQVec, N, kBT) {
        for (let x = 0; x < N; x++) {
            let sumC = 0; species.forEach(s => sumC += s.C[x]);
            const C_mat = Math.max(0, 1 - sumC);
            const C_vec = [C_mat, ...species.map(s => s.C[x])];

            species.forEach((s, idx) => {
                let Q_eff = 0;
                for(let j=0; j<C_vec.length; j++) Q_eff += C_vec[j] * s.qVector[j];
                s.D_star_map[x] = s.d0 * Math.exp(-Q_eff / kBT);
            });
        }
    }
</script>

<script>
    // --- GLOBAL STATE ---
    let worker = null;
    let chartInstance = null;
    let currentTab = 'profile'; 
    let debounceTimer;
    let lastResults = null;
    let lastInputs = null;
    // maps keyed by "Row-Col" where Row and Col are species names (e.g. "Mg-Ni")
    let qMatrixData = {}; 
    let omegaMatrixData = {};

    // --- REASONABLE DEFAULTS (Fixed) ---
    
    // Standard Oxide Values (approximate)
    const CATION_DB = {
        "Sc": { label: "Sc³⁺ (Scandium)",   d0: "4.0e-10" },
        "Ti": { label: "Ti⁴⁺ (Titanium)",   d0: "8.0e-10" },
        "V":  { label: "V³⁺ (Vanadium)",    d0: "6.0e-10" },
        "Cr": { label: "Cr³⁺ (Chromium)",   d0: "3.5e-10" },
        "Mn": { label: "Mn²⁺ (Manganese)",  d0: "1.5e-10" },
        "Fe": { label: "Fe²⁺ (Iron)",       d0: "1.2e-9"  },
        "Co": { label: "Co²⁺ (Cobalt)",     d0: "5.0e-10" },
        "Ni": { label: "Ni²⁺ (Nickel)",     d0: "2.5e-10" },
        "Cu": { label: "Cu²⁺ (Copper)",     d0: "3.0e-10" },
        "Zn": { label: "Zn²⁺ (Zinc)",       d0: "8.0e-10" },
        "Ca": { label: "Ca²⁺ (Calcium)",    d0: "1.0e-10" }
    };


// Realistic Activation Energies (eV) - Added Cu
const Q_DEFAULTS = {
    "Mg": 2.20, "Ni": 2.10, "Co": 2.05, "Fe": 1.95,
    "Zn": 1.85, "Ca": 2.60, "Cr": 2.50, 
    "Cu": 2.15, // Cu diffuses slightly faster than Mg due to JT distortion loosely 'greasing' the path
    "Unk": 2.20
};

// Realistic Interactions (eV) - Updated with your physical intuition
const OMEGA_DEFAULTS = {
    // Mg vs Others
    "Mg-Ni": 0.02, "Mg-Co": 0.03, "Mg-Fe": 0.03, // Ideal-ish
    "Mg-Zn": 0.20, // Structural mismatch (Td preference)
    "Mg-Cu": 0.18, // Jahn-Teller distortion strain
    "Mg-Ca": 0.40, // Large ionic radius mismatch
    "Mg-Cr": 0.50, // Aliovalent (3+) charge mismatch
    
    // Interactions between Dopants (approximations)
    "Ni-Zn": 0.15, "Fe-Zn": 0.15, 
    "Cu-Zn": 0.12, // Cu and Zn mix poorly in oxides
    "Ni-Co": 0.01, // Very ideal
    
    "Default": 0.05
};


    // ---------- WORKER, STATUS, CHART functions (unchanged) ----------
    function createWorker() {
        const blob = new Blob([document.getElementById('worker-code').textContent], {type: "text/javascript"});
        return new Worker(window.URL.createObjectURL(blob));
    }

    function terminateWorker() {
        if (worker) { worker.terminate(); worker = null; updateStatus(0, "Stopped"); }
    }

    function updateStatus(percent, text) {
        const area = document.getElementById('status-area');
        const bar = document.getElementById('header-progress');
        const lbl = document.getElementById('header-status');
        if(text === 'Ready') { area.style.opacity = '0'; } 
        else { area.style.opacity = '1'; bar.style.width = percent + '%'; lbl.innerText = text || (percent + '%'); }
    }


    function validateInputs() {
    // FIX: IDs changed to match HTML ('temp' instead of 'temperature', 'time' instead of 'annealTime')
    const tempElement = document.getElementById('temp');
    const timeElement = document.getElementById('time');
    
    // Safety check in case elements are missing
    if (!tempElement || !timeElement) return null;

    const temp = parseFloat(tempElement.value);
    const timeHours = parseFloat(timeElement.value);
    
    const totalLength = parseFloat(document.getElementById('totalLength').value);
    const sourceLength = parseFloat(document.getElementById('sourceLength').value);
    const N = parseInt(document.getElementById('gridPoints').value);

    if (isNaN(temp) || temp <= 0) {
        alert("Temperature must be a positive number.");
        return null;
    }
    if (isNaN(timeHours) || timeHours <= 0) {
        alert("Anneal time must be a positive number.");
        return null;
    }
    if (isNaN(totalLength) || totalLength <= 0) {
        alert("Total length must be a positive number (µm).");
        return null;
    }
    if (isNaN(sourceLength) || sourceLength <= 0 || sourceLength >= totalLength) {
        alert("Source length must be >0 and < total length.");
        return null;
    }
    if (isNaN(N) || N < 30) {
        alert("Grid points N must be at least 30.");
        return null;
    }

    const elements = [];
    document.querySelectorAll('.element-card').forEach(card => {
        const name = card.querySelector('.el-name').value;
        const d0 = parseFloat(card.querySelector('.el-d0').value);
        const cLeft = parseFloat(card.querySelector('.el-c-left').value);
        const cRight = parseFloat(card.querySelector('.el-c-right').value);
        const color = card.querySelector('.el-color').value;

        elements.push({
            name,
            fullLabel: CATION_DB[name].label,
            d0,
            cLeft,
            cRight,
            color,
            qVector: buildQVector(name),
            omegaVector: buildOmegaVector(name)
        });
    });

    return {
        temp,
        timeHours,
        totalLength,
        sourceLength,
        N,
        elements,

        // FIX: ID changed to match HTML ('targetD0' instead of 'matrixD0')
        targetD0: parseFloat(document.getElementById('targetD0')?.value || "2e-10"),

        matrixQVector: buildQVector("Mg"),
        matrixOmegaVector: buildOmegaVector("Mg")
    };
}

function buildQVector(species) {
    const all = getSpeciesList();
    const vec = [];

    // Matrix site first
    vec.push(qMatrixData[`${species}-Mg`] ?? getQValue(species, "Mg"));

    // Then each cation
    all.slice(1).forEach(other => {
        vec.push(qMatrixData[`${species}-${other}`] ??
                 getQValue(species, other));
    });

    return vec;
}

function buildOmegaVector(species) {
    const all = getSpeciesList();
    const vec = [];

    vec.push(omegaMatrixData[`${species}-Mg`] ??
             getOmegaValue(species, "Mg"));

    all.slice(1).forEach(other => {
        vec.push(omegaMatrixData[`${species}-${other}`] ??
                 getOmegaValue(species, other));
    });

    return vec;
}




    function triggerCalculation() {
        const inputs = validateInputs();
        if(!inputs) return;
        terminateWorker();
        
        // Ensure 3D history is captured if we are on those tabs OR if we just loaded
        inputs.mode = (currentTab === 'time3d' || currentTab === 'flux') ? 'history' : 'snapshot';
        
        worker = createWorker();
        worker.onmessage = function(e) {
            const msg = e.data;
            if (msg.type === 'progress') { 
                updateStatus(msg.percent, msg.percent + '%'); 
            } else if (msg.type === 'complete') {
                updateStatus(100, 'Done');
                setTimeout(() => updateStatus(0, 'Ready'), 1000);
                renderResults(msg, inputs);
                worker.terminate();
            } else if (msg.type === 'error') { 
                console.error(msg.message); updateStatus(0, 'Error'); 
            }
        };
        updateStatus(0, 'Calculating');
        worker.postMessage(inputs);
    }

    function renderResults(res, inputs) {
        lastResults = res;
        lastInputs = inputs;

        if (currentTab === 'profile') {
            const dx = res.dx * 1e6;
            const labels = Array.from({length: inputs.N}, (_, i) => (i * dx).toFixed(2));
            const datasets = res.species.map(s => ({
                label: s.fullLabel,
                data: Array.from(s.C).map(v => v * 100),
                borderColor: s.color, backgroundColor: s.color + '20',
                borderWidth: 2, pointRadius: 0, fill: true, tension: 0.4
            }));
            datasets.unshift({
                label: 'Matrix',
                data: Array.from(res.matrix).map(v => v * 100),
                borderColor: '#6366f1', borderWidth: 2, borderDash: [5,5], 
                pointRadius: 0, fill: false, tension: 0.4
            });
            
            if(chartInstance) chartInstance.destroy();
            chartInstance = new Chart(document.getElementById('diffusionChart'), {
                type: 'line', data: { labels, datasets },
                options: { 
                    responsive: true, maintainAspectRatio: false, animation: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: { 
                        x: { type: 'linear', min: 0, max: inputs.totalLength, title: {display:true, text:'Depth (µm)'} },
                        y: { min: 0, max: 100, title: {display:true, text:'Concentration (%)'} }
                    }
                }
            });
        


        } else if (currentTab === 'flux' || currentTab === 'time3d') {
            // FIX: Robust check for history
            if (!res.species[0].history || res.species[0].history.length === 0) {
                console.warn("History missing. Re-running.");
                triggerCalculation(); 
                return;
            }

            const xData = Array.from({length: inputs.N}, (_, i) => i * (res.dx * 1e6));
            const yData = res.species[0].history.map((_, i) => i * (inputs.timeHours / res.species[0].history.length));
            
            const traces = res.species.map(s => {
                let zData;
                if(currentTab === 'flux') zData = s.fluxHistory.map(row => Array.from(row));
                else zData = s.history.map(row => Array.from(row).map(v => v*100));

                return {
                    type: 'surface', x: xData, y: yData, z: zData,
                    name: s.name, showscale: false, showlegend: true, opacity: 0.85,
                    colorscale: [ [0, '#ffffff'], [1, s.color] ]
                };
            });

            Plotly.newPlot(currentTab === 'flux' ? 'plotly-flux' : 'plotly-time', traces, {
                margin: {l:0,r:0,b:0,t:30}, showlegend: true, legend: { x: 0, y: 1 },
                scene: { 
                    aspectmode: 'cube',
                    xaxis:{title:'Depth (µm)'}, yaxis:{title:'Time (h)'}, 
                    zaxis:{title: currentTab === 'flux' ? 'Flux' : 'Conc (%)'}, 
                    camera: { eye: { x: 1.5, y: 1.5, z: 1.3 } } 
                }
            });
        }
    }







    

    // --- INPUTS & DEFAULTS (existing helpers) ---
    function getQValue(diffuser, env) {
        const dQ = Q_DEFAULTS[diffuser] || Q_DEFAULTS["Unk"];
        const eQ = Q_DEFAULTS[env] || Q_DEFAULTS["Unk"];
        // return number (not string)
        return ((dQ + eQ) / 2);
    }

    function getOmegaValue(s1, s2) {
        if (s1 === s2) return 0.00;
        const key1 = `${s1}-${s2}`;
        const key2 = `${s2}-${s1}`;
        if (OMEGA_DEFAULTS[key1] !== undefined) return OMEGA_DEFAULTS[key1];
        if (OMEGA_DEFAULTS[key2] !== undefined) return OMEGA_DEFAULTS[key2];
        return OMEGA_DEFAULTS["Default"];
    }

    // -------------------------
    // species helpers & preserve logic
    // -------------------------

    function getSpeciesList() {
    const dopants = [];
    document.querySelectorAll('.element-card').forEach(card => {
        const sel = card.querySelector('.el-name');
        // FIX: Use .value (e.g., "Ni") instead of parsing text (e.g., "Ni²⁺")
        const name = sel.value || "Unk"; 
        dopants.push(name);
    });
    return ["Mg", ...dopants];
}

    function keyFor(a,b){ return `${a}-${b}`; }

    // Preserve previously edited entries where species still exist; auto-fill new pairs from defaults
    function rebuildMatricesPreserve() {
      const species = getSpeciesList();
      const newQ = {};
      const newOmega = {};

      // for every pair in new species, copy old value if present, else fill default
      species.forEach(r => {
        species.forEach(c => {
          const k = keyFor(r,c);
          if (qMatrixData[k] !== undefined) newQ[k] = qMatrixData[k];
          else newQ[k] = getQValue(r,c);

          if (omegaMatrixData[k] !== undefined) newOmega[k] = omegaMatrixData[k];
          else newOmega[k] = getOmegaValue(r,c);
        });
      });

      // ensure omega symmetry: if user edited only one side, reflect to mirror
      species.forEach(r=>{
        species.forEach(c=>{
          if (r === c) { newOmega[keyFor(r,c)] = 0.0; return; }
          const a = keyFor(r,c), b = keyFor(c,r);
          // prefer already-specified symmetry: if one side differs, set both to the more recently present one.
          if (newOmega[a] !== undefined && newOmega[b] === undefined) newOmega[b] = newOmega[a];
          if (newOmega[b] !== undefined && newOmega[a] === undefined) newOmega[a] = newOmega[b];
          // if both exist but differ, prefer existing 'a' value (arbitrary but consistent)
          // (user can edit later)
          newOmega[b] = newOmega[a];
        });
      });

      qMatrixData = newQ;
      omegaMatrixData = newOmega;
    }

    // -------------------------
    //  build HTML tables & attach listeners
    // -------------------------
function buildMatrixTables() {
    const species = getSpeciesList();

    // --- Helper to create cells ---
    const createCell = (r, c, val, type) => {
        const rIdx = species.indexOf(r);
        const cIdx = species.indexOf(c);
        const isDiag = (r === c);
        const isLower = (rIdx > cIdx); 

        // CASE 1: Lower Diagonal -> Disabled & Grey
        if (isLower) {
            return `<td style="background:#f1f5f9; padding:4px; border-bottom:1px solid #e2e8f0;">
                <input type="text" disabled value="" 
                       style="width:70px; padding:4px; border:1px solid #e2e8f0; background:transparent; cursor:not-allowed;">
            </td>`;
        }

        // CASE 2: Regular Cell (Upper Triangle + Diagonal)
        let disabled = "";
        let bgStyle = "";
        
        // For Omega, diagonal is always 0 and disabled
        if (type === 'omega' && isDiag) {
             disabled = "disabled";
             bgStyle = "background:#f8fafc; color:#94a3b8;";
        }

        return `<td style="padding:4px; border-bottom:1px solid #e2e8f0; text-align:center;">
            <input type="number" class="${type}-cell" data-row="${r}" data-col="${c}" value="${val}" step="0.01" ${disabled}
                   style="width:70px; padding:4px; border:1px solid #cbd5e1; text-align:center; ${bgStyle}">
        </td>`;
    };

    // --- Build Q Table ---
    const qTable = document.getElementById('q-matrix-table');
    let html = '<thead><tr><th style="padding:8px; text-align:left; background:#e2e8f0;">Diffuser \\ Env</th>';
    species.forEach(s => html += `<th style="padding:8px; background:#f1f5f9; text-align:center;">${s}</th>`);
    html += '</tr></thead><tbody>';
    
    species.forEach(r => {
        html += `<tr><td style="font-weight:bold; padding:8px; border-bottom:1px solid #e2e8f0;">${r}</td>`;
        species.forEach(c => {
            const k = keyFor(r,c);
            const val = (qMatrixData[k] !== undefined) ? Number(qMatrixData[k]).toFixed(3) : Number(getQValue(r,c)).toFixed(3);
            html += createCell(r, c, val, 'q');
        });
        html += '</tr>';
    });
    html += '</tbody>';
    qTable.innerHTML = html;

    // --- Build Omega Table ---
    const oTable = document.getElementById('omega-matrix-table');
    let ohtml = '<thead><tr><th style="padding:8px; text-align:left; background:#e2e8f0;">Pair</th>';
    species.forEach(s => ohtml += `<th style="padding:8px; background:#f1f5f9; text-align:center;">${s}</th>`);
    ohtml += '</tr></thead><tbody>';
    
    species.forEach(r => {
        ohtml += `<tr><td style="font-weight:bold; padding:8px; border-bottom:1px solid #e2e8f0;">${r}</td>`;
        species.forEach(c => {
            const k = keyFor(r,c);
            const val = (omegaMatrixData[k] !== undefined) ? Number(omegaMatrixData[k]).toFixed(3) : Number(getOmegaValue(r,c)).toFixed(3);
            ohtml += createCell(r, c, val, 'omega');
        });
        ohtml += '</tr>';
    });
    ohtml += '</tbody>';
    oTable.innerHTML = ohtml;

    attachMatrixListeners();
}

    function attachMatrixListeners(){
    // Q Listeners (Symmetry is NOT required for Q physically, but often assumed. 
    // Usually Q_ij != Q_ji (Diffuser i in Env j vs Diffuser j in Env i).
    // So we ONLY update the specific cell for Q unless you want forced symmetry.)
    document.querySelectorAll('.q-cell').forEach(inp => {
        inp.oninput = () => {
            const r = inp.dataset.row, c = inp.dataset.col;
            const v = parseFloat(inp.value);
            if (!isNaN(v)) qMatrixData[keyFor(r,c)] = v;
        };
    });

    // Omega Listeners (STRICTLY SYMMETRIC)
    document.querySelectorAll('.omega-cell').forEach(inp => {
        inp.oninput = () => {
            const r = inp.dataset.row, c = inp.dataset.col;
            const v = parseFloat(inp.value);
            if (!isNaN(v)) {
                // 1. Update this cell (e.g. Mg-Zn)
                omegaMatrixData[keyFor(r,c)] = v;
                // 2. Automatically update the hidden symmetric twin (e.g. Zn-Mg)
                omegaMatrixData[keyFor(c,r)] = v;
            }
        };
    });
}
    // -------------------------
    // OPEN/CLOSE modal (use preserve logic)
    // -------------------------
    function openInteractionModal() {
      // preserve user edits; add defaults for new species
      rebuildMatricesPreserve();
      buildMatrixTables();
      document.getElementById('interaction-modal').style.display = 'flex';
    }

    function closeInteractionModal() {
      // read final values from inputs (listeners already update maps, but ensure parsing)
      document.querySelectorAll('.q-cell').forEach(inp=>{
        const k = keyFor(inp.dataset.row, inp.dataset.col);
        const v = parseFloat(inp.value);
        if (!isNaN(v)) qMatrixData[k] = v;
      });
      document.querySelectorAll('.omega-cell').forEach(inp=>{
        const k = keyFor(inp.dataset.row, inp.dataset.col);
        const v = parseFloat(inp.value);
        if (!isNaN(v)) {
          omegaMatrixData[k] = v;
          omegaMatrixData[keyFor(inp.dataset.col, inp.dataset.row)] = v;
        }
      });

      document.getElementById('interaction-modal').style.display = 'none';
      debouncedUpdate();
    }

    // keep syncSymmetry for any inline handlers (backwards compatibility)
    function syncSymmetry(input) {
      const r = input.dataset.row, c = input.dataset.col;
      const mirror = document.querySelector(`.omega-cell[data-row="${c}"][data-col="${r}"]`);
      if (mirror) mirror.value = input.value;
      // update maps
      const v = parseFloat(input.value);
      if (!isNaN(v)) {
        omegaMatrixData[keyFor(r,c)] = v;
        omegaMatrixData[keyFor(c,r)] = v;
      }
    }

    // -------------------------
    // Preserve-aware addElement / updateElementParams
    // -------------------------
    function addElement(initialKey = "Ni") {
        const list = document.getElementById('elementsList');
        if (list.children.length >= 4) { alert("Max 4 dopants"); return; }
        
        const template = document.getElementById('elementTemplate');
        const clone = template.content.cloneNode(true);
        const card = clone.querySelector('.element-card');
        const color = ['#ef4444', '#10b981', '#f59e0b', '#8b5cf6'][list.children.length % 4];
        
        card.style.borderLeftColor = color;
        clone.querySelector('.el-color').value = color;
        
        const select = clone.querySelector('.el-name');
        const keys = Object.keys(CATION_DB);
        keys.forEach(k => { const opt = document.createElement('option'); opt.value = k; opt.text = CATION_DB[k].label; select.appendChild(opt); });
        
        select.value = initialKey;
        const data = CATION_DB[initialKey];
        clone.querySelector('.el-d0').value = data.d0;
        clone.querySelector('.el-c-left').value = 25; clone.querySelector('.el-c-right').value = 0;

        // delete handler: remove element, preserve other edits, rebuild matrices preserving existing entries
        clone.querySelector('.delete-btn').onclick = (e) => { 
          e.target.closest('.element-card').remove(); 
          rebuildMatricesPreserve(); 
          // if modal open, refresh tables to reflect removal
          if (document.getElementById('interaction-modal').style.display === 'flex') buildMatrixTables();
          debouncedUpdate(); 
        };

        // onchange: update d0 and rebuild matrices preserving edits (if cation changed)
        select.onchange = function() {
          const data = CATION_DB[select.value];
          select.closest('.element-card').querySelector('.el-d0').value = data.d0;
          // when the species changes (e.g. Ni -> Co), we want to preserve any entries that still match
          rebuildMatricesPreserve();
          if (document.getElementById('interaction-modal').style.display === 'flex') buildMatrixTables();
          debouncedUpdate();
        };

        list.appendChild(clone);

        // after adding, rebuild matrices preserving existing edits; new pairs get defaults
        rebuildMatricesPreserve();
        if (document.getElementById('interaction-modal').style.display === 'flex') buildMatrixTables();
        debouncedUpdate();
    }

    function updateElementParams(select) {
        const data = CATION_DB[select.value];
        select.closest('.element-card').querySelector('.el-d0').value = data.d0;
        // species list changed semantics — preserve previous edits if possible and refresh modal if open
        rebuildMatricesPreserve();
        if (document.getElementById('interaction-modal').style.display === 'flex') buildMatrixTables();
        debouncedUpdate();
    }

    function downloadData() {
    if (!lastResults || !lastInputs) {
        alert("No simulation data found. Please run a calculation first.");
        return;
    }

    // --- 1. METADATA HEADER ---
    let csv = "--- GLOBAL PARAMETERS ---\n";
    csv += `Temperature (K),${lastInputs.temp}\n`;
    csv += `Time (Hours),${lastInputs.timeHours}\n`;
    csv += `Source Length (um),${lastInputs.sourceLength}\n`;
    csv += `Total Length (um),${lastInputs.totalLength}\n`;
    csv += `Grid Points,${lastInputs.N}\n`;
    csv += `Matrix Base D0 (m^2/s),${lastInputs.targetD0}\n`;

    // --- 2. DOPANT DEFINITIONS ---
    csv += "\n--- DOPANT SETTINGS ---\n";
    csv += "Species,D0 (m^2/s),Source %,Matrix %\n";
    lastInputs.elements.forEach(el => {
        csv += `${el.name},${el.d0},${el.cLeft},${el.cRight}\n`;
    });

    // --- 3. INTERACTION MATRICES ---
    // We iterate over the global maps to print the exact pairs used
    csv += "\n--- KINETICS MATRIX (Q in eV) ---\n";
    csv += "Pair,Value\n";
    // Sort keys for tidiness
    Object.keys(qMatrixData).sort().forEach(key => {
        csv += `${key},${qMatrixData[key]}\n`;
    });

    csv += "\n--- THERMO MATRIX (Omega in eV) ---\n";
    csv += "Pair,Value\n";
    Object.keys(omegaMatrixData).sort().forEach(key => {
        csv += `${key},${omegaMatrixData[key]}\n`;
    });

    // --- 4. SIMULATION DATA ---
    csv += "\n--- CALCULATION RESULTS ---\n";
    
    // Create Columns Header: Depth, Matrix, [Spec1 Conc, Spec1 Flux], ...
    const speciesHeaders = lastResults.species
        .map(s => `${s.name} Conc (%),${s.name} Flux (mol/m2s)`)
        .join(",");
        
    csv += `Depth (um),Matrix Conc (%),${speciesHeaders}\n`;

    // Write Rows
    const dx = lastResults.dx * 1e6; // Convert m to um
    for (let i = 0; i < lastInputs.N; i++) {
        const depth = (i * dx).toFixed(4);
        const matC = (lastResults.matrix[i] * 100).toFixed(4);
        
        // Map species data for this row
        const spData = lastResults.species.map(s => {
            return `${(s.C[i] * 100).toFixed(4)},${s.Flux[i].toExponential(4)}`;
        }).join(",");

        csv += `${depth},${matC},${spData}\n`;
    }

    // --- 5. TRIGGER DOWNLOAD ---
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    
    // Create a filename with timestamp
    const date = new Date().toISOString().slice(0,10);
    link.setAttribute("href", url);
    link.setAttribute("download", `OnsagerDiff_${date}.csv`);
    
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}


    function debouncedUpdate() { clearTimeout(debounceTimer); debounceTimer = setTimeout(triggerCalculation, 600); }
    
    function switchTab(tab) {
        currentTab = tab;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.getElementById('tab-' + tab).classList.add('active');
        document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
        document.getElementById('pane-' + tab).classList.add('active');
        if(tab === 'time3d' || tab === 'flux') window.dispatchEvent(new Event('resize'));
        if(tab !== 'help') triggerCalculation();
    }

    window.onload = function() { 
      addElement("Ni"); 
      // ensure matrices populated initially
      rebuildMatricesPreserve();
    };
</script>




</body>
</html>