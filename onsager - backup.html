<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Onsager Diffusion v7.5 (Clean UI)</title>
    <link href="./dist/output.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    
    <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body class="h-screen flex flex-col overflow-hidden text-slate-800 bg-slate-50 font-sans">

    <div class="bg-white border-b border-gray-200 px-4 flex items-center justify-between shrink-0 h-14 shadow-sm z-20">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 bg-orange-600 rounded flex items-center justify-center text-white font-bold shadow-md">
                <i class="fas fa-project-diagram"></i>
            </div>
            <h1 class="font-bold text-lg text-slate-800 hidden md:block">Onsager Diffusion <span class="text-xs font-normal text-slate-500 ml-1">v7.5 (Coupled)</span></h1>
        </div>
        
        <div id="status-area" class="flex-1 mx-8 flex items-center gap-3 opacity-0 transition-opacity duration-300">
            
            
            <div class="h-1.5 flex-1 bg-gray-100 rounded-full overflow-hidden">
                <div id="header-progress" class="h-full bg-orange-500 w-0 transition-all duration-200"></div>
            </div>
            <span id="header-status" class="text-xs font-mono text-gray-400 w-24 text-right">Calculating...</span>
            <button onclick="terminateWorker()" class="text-xs text-red-500 hover:text-red-700 font-bold uppercase" title="Stop">
                <i class="fas fa-stop"></i>
            </button>
        </div>

        <div class="flex space-x-1 h-full overflow-x-auto mx-4">
            <button onclick="switchTab('profile')" id="tab-profile" class="tab-btn active h-full flex items-center">
                <i class="fas fa-chart-line mr-2"></i> Profile
            </button>
            <button onclick="switchTab('flux')" id="tab-flux" class="tab-btn h-full flex items-center">
                <i class="fas fa-exchange-alt mr-2"></i> Fluxes
            </button>
            <button onclick="switchTab('time3d')" id="tab-time3d" class="tab-btn h-full flex items-center">
                <i class="fas fa-cube mr-2"></i> 3D View
            </button>
            <button onclick="switchTab('help')" id="tab-help" class="tab-btn h-full flex items-center text-emerald-600">
                <i class="fas fa-info-circle mr-2"></i> Theory
            </button>
        </div>
    </div>

    <div class="flex flex-1 overflow-hidden relative">
        
        <aside class="w-full md:w-80 bg-white border-r border-gray-200 flex flex-col h-full z-10 shadow-[4px_0_24px_rgba(0,0,0,0.02)] shrink-0 overflow-y-auto">
            <div class="p-4 space-y-5">
                
                <div class="bg-orange-50 p-4 rounded-lg border border-orange-200 shadow-sm">
                    <div class="flex items-center gap-2 mb-3 border-b border-orange-200 pb-2">
                        <i class="fas fa-ruler-combined text-orange-600"></i>
                        <h3 class="text-xs font-bold text-orange-800 uppercase tracking-wider">1. Geometry</h3>
                    </div>
                    <div class="grid grid-cols-2 gap-3">
                        <div class="input-group">
                            <label class="text-[10px] text-orange-700 font-bold block mb-1">Source Thickness (µm)</label>
                            <input type="number" id="sourceLength" value="50" min="0.1" step="0.1" class="w-full text-sm border border-orange-300 rounded p-1.5 font-semibold bg-white text-orange-900 focus:ring-2 focus:ring-orange-200 outline-none" onchange="debouncedUpdate()">
                        </div>
                        <div class="input-group">
                            <label class="text-[10px] text-orange-700 font-bold block mb-1">Total Length (µm)</label>
                            <input type="number" id="totalLength" value="250" min="1" step="1" class="w-full text-sm border border-orange-300 rounded p-1.5 font-semibold bg-white text-orange-900 focus:ring-2 focus:ring-orange-200 outline-none" onchange="debouncedUpdate()">
                        </div>
                        <div class="input-group col-span-2">
                            <label class="text-[10px] text-orange-700 font-bold block mb-1">Grid Points</label>
                            <input type="number" id="gridPoints" value="100" min="50" max="400" class="w-full text-sm border border-orange-300 rounded p-1.5 font-semibold bg-white focus:ring-2 focus:ring-orange-200 outline-none" onchange="debouncedUpdate()">
                        </div>
                    </div>
                </div>

                <div class="bg-slate-50 p-3 rounded border border-slate-200">
                    <h3 class="text-xs font-bold text-slate-500 uppercase tracking-wider mb-2">2. Conditions</h3>
                    <div class="grid grid-cols-2 gap-2">
                        <div class="input-group">
                            <label class="text-[10px] text-gray-500 font-bold block">Temp (K)</label>
                            <input type="number" id="temp" value="1600" min="800" max="2800" class="w-full text-sm border border-gray-300 rounded p-1" onchange="debouncedUpdate()">
                        </div>
                        <div class="input-group">
                            <label class="text-[10px] text-gray-500 font-bold block">Time (Hours)</label>
                            <input type="number" id="time" value="48" min="0.1" step="0.1" class="w-full text-sm border border-gray-300 rounded p-1" onchange="debouncedUpdate()">
                        </div>
                    </div>
                </div>

                <div class="bg-indigo-50 p-3 rounded border border-indigo-100">
                    <h3 class="text-xs font-bold text-indigo-800 uppercase tracking-wider mb-2">3. Matrix (MgO)</h3>
                    <div class="grid grid-cols-2 gap-2">
                        <div>
                            <label class="text-[10px] text-indigo-600 font-bold block">D₀ (m²/s)</label>
                            <input type="text" id="targetD0" value="5.0e-11" class="w-full text-xs border border-indigo-200 rounded p-1" onchange="debouncedUpdate()">
                        </div>
                        <div>
                            <label class="text-[10px] text-indigo-600 font-bold block">Q (eV)</label>
                            <input type="number" id="targetQ" value="2.0" step="0.1" class="w-full text-xs border border-indigo-200 rounded p-1" onchange="debouncedUpdate()">
                        </div>
                    </div>
                </div>

                <div>
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-xs font-bold text-slate-500 uppercase tracking-wider">4. Dopants</h3>
                        <button onclick="addElement()" class="text-[10px] bg-indigo-600 hover:bg-indigo-700 text-white px-2 py-1 rounded transition shadow-sm font-bold">
                            <i class="fas fa-plus"></i> ADD
                        </button>
                    </div>
                    <div id="elementsList" class="space-y-3"></div>
                </div>
            </div>
        </aside>

        <main class="flex-1 flex flex-col h-full relative bg-slate-100 overflow-hidden">
            <div id="loading-overlay" class="absolute inset-0 z-50 bg-white/80 backdrop-blur-sm hidden flex-col items-center justify-center">
                <div class="bg-white p-6 rounded-xl shadow-xl border border-gray-100 flex flex-col items-center">
                    <div class="spinner mb-3"></div>
                    <span class="text-sm font-bold text-slate-700">Calculating Coupled Fluxes...</span>
                </div>
            </div>

            <div id="pane-profile" class="tab-pane active relative p-4">
                <div class="bg-white w-full h-full rounded-lg shadow-sm border border-gray-200 p-4 flex flex-col">
                    <div class="flex-1 relative">
                        <canvas id="diffusionChart"></canvas>
                    </div>
                </div>
            </div>

            <div id="pane-flux" class="tab-pane relative p-4">
                 <div class="bg-white w-full h-full rounded-lg shadow-sm border border-gray-200 p-4 flex flex-col">
                    <div class="flex-1 relative">
                        <canvas id="fluxChart"></canvas>
                    </div>
                </div>
            </div>

            <div id="pane-time3d" class="tab-pane relative">
                 <div id="plotly-time" class="w-full h-full"></div>
            </div>


            <div id="pane-help" class="tab-pane overflow-y-auto p-8 bg-white">
                <div class="max-w-4xl mx-auto pb-20 help-content">
                    
                    <div class="border-b border-gray-200 pb-4 mb-6">
                        <h1 class="text-3xl font-bold text-slate-800">Theory & Model Description</h1>
                        <p class="text-slate-500 mt-2">Onsager Multi-Component Diffusion Solver (v8.0)</p>
                    </div>

                    <div class="bg-blue-50 border-l-4 border-blue-500 p-4 mb-8 text-sm text-blue-900 shadow-sm rounded-r">
                        <strong>Overview:</strong> This simulation solves the diffusion of multiple dopants simultaneously. Unlike simple calculators, it accounts for how the movement of one species (e.g., Ni) physically drags or blocks another (e.g., Mg or Vacancies) through <strong>Lattice Coupling</strong>.
                    </div>

                    <h2 class="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2">
                        <span class="w-8 h-8 rounded bg-indigo-100 text-indigo-600 flex items-center justify-center text-sm">1</span>
                        The Governing Equations
                    </h2>
                    
                    <p class="text-slate-600 mb-4">
                        In a multi-component system, the flux of species $i$ ($J_i$) is not just driven by its own concentration gradient ($\nabla C_i$), but also by the gradients of all other species $j$. This is described by the <strong>Onsager formalism</strong>:
                    </p>

                    <div class="bg-slate-50 border border-slate-200 rounded p-6 mb-6 text-center overflow-x-auto">
                        $$ J_i = - \underbrace{D_{ii} \frac{\partial C_i}{\partial x}}_{\text{Self-Diffusion}} - \underbrace{\sum_{j \neq i} D_{ij} \frac{\partial C_j}{\partial x}}_{\text{Coupled Drag}} $$
                    </div>

                    <p class="text-slate-600 mb-4">
                        This tool implements the <strong>Manning-Darken approximation</strong> for vacancy-mediated diffusion on a lattice. The diffusion coefficients $D_{ij}$ are calculated dynamically at every grid point:
                    </p>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-8">
                        <div class="bg-white border border-gray-200 p-4 rounded shadow-sm">
                            <h4 class="font-bold text-indigo-600 text-sm mb-2 uppercase">Diagonal Term (Main)</h4>
                            <p class="text-sm text-gray-700 mb-2">The primary driving force, modified by the matrix response.</p>
                            <div class="text-center py-2 bg-indigo-50 rounded">
                                $D_{ii} = D^*_i + C_i (D^*_{matrix} - D^*_i)$
                            </div>
                        </div>
                        <div class="bg-white border border-gray-200 p-4 rounded shadow-sm">
                            <h4 class="font-bold text-orange-600 text-sm mb-2 uppercase">Off-Diagonal (Cross)</h4>
                            <p class="text-sm text-gray-700 mb-2">The "Vacancy Wind" effect. Fast atoms create vacancy flows that drag slow atoms.</p>
                            <div class="text-center py-2 bg-orange-50 rounded">
                                $D_{ij} = C_i (D^*_{matrix} - D^*_j)$
                            </div>
                        </div>
                    </div>

                    <h2 class="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2">
                        <span class="w-8 h-8 rounded bg-orange-100 text-orange-600 flex items-center justify-center text-sm">2</span>
                        Comparison: Onsager vs. Fick
                    </h2>

                    <div class="overflow-hidden rounded-lg border border-gray-200 shadow-sm mb-8">
                        <table class="w-full text-sm text-left text-gray-600">
                            <thead class="text-xs text-gray-700 uppercase bg-gray-50 border-b">
                                <tr>
                                    <th class="px-6 py-3 w-1/4">Feature</th>
                                    <th class="px-6 py-3 w-1/3">Simple Fick's Law ($J = -D\nabla C$)</th>
                                    <th class="px-6 py-3 text-orange-700 bg-orange-50">Onsager / Coupled (This Tool)</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-200">
                                <tr class="bg-white hover:bg-gray-50">
                                    <td class="px-6 py-4 font-bold text-gray-900">Interaction</td>
                                    <td class="px-6 py-4">None. Atoms move independently.</td>
                                    <td class="px-6 py-4 bg-orange-50/30 font-semibold text-gray-900">Highly Coupled.</td>
                                </tr>
                                <tr class="bg-white hover:bg-gray-50">
                                    <td class="px-6 py-4 font-bold text-gray-900">Direction</td>
                                    <td class="px-6 py-4">Always "Downhill" (High $\to$ Low conc).</td>
                                    <td class="px-6 py-4 bg-orange-50/30">Can be <strong>"Uphill"</strong> (against gradient).</td>
                                </tr>
                                <tr class="bg-white hover:bg-gray-50">
                                    <td class="px-6 py-4 font-bold text-gray-900">Mechanism</td>
                                    <td class="px-6 py-4">Random Walk.</td>
                                    <td class="px-6 py-4 bg-orange-50/30"><strong>Vacancy Wind.</strong> A flux of atoms Right causes a flux of vacancies Left, influencing other atoms.</td>
                                </tr>
                                <tr class="bg-white hover:bg-gray-50">
                                    <td class="px-6 py-4 font-bold text-gray-900">Interface</td>
                                    <td class="px-6 py-4">Stationary.</td>
                                    <td class="px-6 py-4 bg-orange-50/30"><strong>Kirkendall Shift.</strong> The interface moves if species diffuse at different rates.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h2 class="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2">
                        <span class="w-8 h-8 rounded bg-emerald-100 text-emerald-600 flex items-center justify-center text-sm">3</span>
                        What to look for
                    </h2>
                    
                    <ul class="space-y-4 text-slate-700 list-disc pl-5">
                        <li>
                            <strong>Uphill Diffusion:</strong> If you add a fast dopant (e.g., Fe) and a slow dopant (e.g., Ni), you may see the slow dopant pile up or dip strangely near the interface. This is the fast dopant "stealing" the available vacancies.
                        </li>
                        <li>
                            <strong>The "S-Curve":</strong> In Fickian diffusion, profiles are simple Error Functions (smooth curves). In Onsager diffusion, profiles can become asymmetrical or develop kinks due to the concentration-dependence of $D_{ij}$.
                        </li>
                    </ul>

                </div>
            </div>


        </main>
    </div>

    <template id="elementTemplate">
        <div class="element-card bg-white p-3 rounded border border-gray-300 shadow-sm relative group border-l-4 mb-2">
            <input type="hidden" class="el-color">
            <button class="delete-btn absolute top-1 right-2 text-gray-300 hover:text-red-500 hidden group-hover:block transition" title="Remove">
                <i class="fas fa-times"></i>
            </button>
            <div class="grid grid-cols-2 gap-2 mb-2">
                <div class="col-span-2">
                    <label class="text-[10px] text-gray-500 font-bold block">Dopant</label>
                    <select class="el-name border border-gray-300 rounded text-xs w-full p-1 font-semibold text-slate-700" onchange="updateElementParams(this)">
                    </select>
                </div>
                <div>
                    <label class="text-[10px] text-gray-500 font-bold block">D*₀</label>
                    <input type="text" class="el-d0 text-xs border border-gray-300 rounded p-1 w-full" onchange="debouncedUpdate()">
                </div>
                <div>
                    <label class="text-[10px] text-gray-500 font-bold block">Q (eV)</label>
                    <input type="number" class="el-q text-xs border border-gray-300 rounded p-1 w-full" step="0.1" onchange="debouncedUpdate()">
                </div>
                <div class="col-span-2 flex items-center gap-2">
                    <div class="flex-1">
                        <label class="text-[10px] text-gray-500 font-bold block">Source %</label>
                        <input type="number" class="el-c-left text-xs border border-gray-300 rounded p-1 w-full" min="0" max="100" onchange="debouncedUpdate()">
                    </div>
                    <div class="flex-1">
                        <label class="text-[10px] text-gray-500 font-bold block">Matrix %</label>
                        <input type="number" class="el-c-right text-xs border border-gray-300 rounded p-1 w-full" min="0" max="100" onchange="debouncedUpdate()">
                    </div>
                </div>
            </div>
        </div>
    </template>

    <script id="worker-code" type="javascript/worker">
        const KB_EV = 8.617333262145e-5; 

        self.onmessage = function(e) {
            const inputs = e.data;
            try {
                const Temp = inputs.temp;
                const Time_s = inputs.timeHours * 3600;
                const N = inputs.N;
                const L_m = inputs.totalLength * 1e-6; 
                const Source_m = inputs.sourceLength * 1e-6;
                const dx = L_m / (N - 1);
                
                const interfaceNode = Math.round(Source_m / dx);

                // Setup Species
                const matExp = -inputs.targetQ / (KB_EV * Temp);
                const D_star_matrix = inputs.targetD0 * Math.exp(matExp);

                const species = inputs.elements.map(el => {
                    const exp = -el.q / (KB_EV * Temp);
                    const D_star = el.d0 * Math.exp(exp);
                    const C = new Float64Array(N);
                    for(let i=0; i<N; i++) {
                        C[i] = (i < interfaceNode) ? el.cLeft / 100 : el.cRight / 100;
                    }
                    return { ...el, D_star, C, C_new: new Float64Array(N), Flux: new Float64Array(N), history: [] };
                });

                let maxD = D_star_matrix;
                species.forEach(s => maxD = Math.max(maxD, s.D_star));
                if (maxD < 1e-35) maxD = 1e-35;

                let dt = (0.3 * dx * dx) / maxD;
                let totalSteps = Math.ceil(Time_s / dt);

                if(totalSteps > 1500000) {
                    totalSteps = 1500000;
                    dt = Time_s / totalSteps;
                }

                const saveInterval = Math.max(1, Math.floor(totalSteps / 40));
                const reportInterval = Math.max(100, Math.floor(totalSteps / 50));

                for (let t = 0; t < totalSteps; t++) {
                    for (let i = 0; i < N - 1; i++) {
                        const C_local = species.map(s => (s.C[i] + s.C[i+1]) / 2);
                        const grads = species.map(s => (s.C[i+1] - s.C[i]) / dx);
                        
                        // ONSAGER MATRIX (Darken-Manning)
                        species.forEach((s_i, idx_i) => {
                            let flux = 0;
                            species.forEach((s_j, idx_j) => {
                                let D_ij = 0;
                                if (idx_i === idx_j) {
                                    D_ij = s_i.D_star + C_local[idx_i] * (D_star_matrix - s_i.D_star);
                                } else {
                                    D_ij = C_local[idx_i] * (D_star_matrix - s_j.D_star);
                                }
                                flux += -1 * D_ij * grads[idx_j];
                            });
                            s_i.Flux[i] = flux;
                        });
                    }

                    for (let i = 1; i < N - 1; i++) {
                        species.forEach(s => {
                            const dJ_dx = (s.Flux[i] - s.Flux[i-1]) / dx;
                            s.C_new[i] = s.C[i] - dt * dJ_dx;
                        });
                    }
                    species.forEach(s => { s.C_new[0] = s.C_new[1]; s.C_new[N-1] = s.C_new[N-2]; });
                    species.forEach(s => {
                        const temp = s.C; s.C = s.C_new; s.C_new = temp;
                        if (inputs.mode === 'history' && t % saveInterval === 0) s.history.push(Float64Array.from(s.C));
                    });
                    if (t % reportInterval === 0) self.postMessage({ type: 'progress', percent: Math.round((t / totalSteps) * 100) });
                }

                const finalMatrix = new Float64Array(N);
                for(let i=0; i<N; i++) {
                    let sum = 0;
                    species.forEach(s => sum += s.C[i]);
                    finalMatrix[i] = Math.max(0, 1 - sum);
                }

                self.postMessage({ type: 'complete', species, matrix: finalMatrix, dx, interfaceX: Source_m });
            } catch (err) {
                self.postMessage({ type: 'error', message: err.message });
            }
        };
    </script>

<script>
let worker = null;
    let chartInstance = null;
    let fluxChartInstance = null;
    let currentTab = 'profile';
    let debounceTimer;

    // --- GLOBAL STORAGE FOR EXPORT ---
    let lastResults = null;
    let lastInputs = null;

    // --- 3D TRANSITION METAL SERIES (Estimated for MgO) ---
    const CATION_DB = {
        "Sc": { label: "Sc³⁺ (Scandium)",   d0: "4.0e-10", q: 1.6 },
        "Ti": { label: "Ti⁴⁺ (Titanium)",   d0: "8.0e-10", q: 1.5 },
        "V":  { label: "V³⁺ (Vanadium)",    d0: "6.0e-10", q: 1.6 },
        "Cr": { label: "Cr³⁺ (Chromium)",   d0: "3.5e-10", q: 1.7 },
        "Mn": { label: "Mn²⁺ (Manganese)",  d0: "1.5e-10", q: 1.8 },
        "Fe": { label: "Fe²⁺ (Iron)",       d0: "1.2e-9",  q: 1.6 },
        "Co": { label: "Co²⁺ (Cobalt)",     d0: "5.0e-10", q: 1.7 },
        "Ni": { label: "Ni²⁺ (Nickel)",     d0: "2.5e-10", q: 1.8 },
        "Cu": { label: "Cu²⁺ (Copper)",     d0: "3.0e-10", q: 1.7 },
        "Zn": { label: "Zn²⁺ (Zinc)",       d0: "8.0e-10", q: 1.6 }
    };

    function createWorker() {
        const blob = new Blob([document.getElementById('worker-code').textContent], {type: "text/javascript"});
        return new Worker(window.URL.createObjectURL(blob));
    }

    function terminateWorker() {
        if (worker) { worker.terminate(); worker = null; updateStatus(0, "Stopped"); }
    }

    function updateStatus(percent, text) {
        const area = document.getElementById('status-area');
        const bar = document.getElementById('header-progress');
        const lbl = document.getElementById('header-status');
        if(text === 'Ready') { area.style.opacity = '0'; } 
        else { area.style.opacity = '1'; bar.style.width = percent + '%'; lbl.innerText = text || (percent + '%'); }
    }

    function triggerCalculation() {
        const inputs = validateInputs();
        if(!inputs) return;
        terminateWorker();
        inputs.mode = (currentTab === 'time3d') ? 'history' : 'snapshot';
        // If viewing flux, we simulate 30% of time to see dynamic flux
        if(currentTab === 'flux') inputs.timeHours = inputs.timeHours * 0.3;
        
        worker = createWorker();
        worker.onmessage = function(e) {
            const msg = e.data;
            if (msg.type === 'progress') { updateStatus(msg.percent, msg.percent + '%'); } 
            else if (msg.type === 'complete') {
                updateStatus(100, 'Done');
                setTimeout(() => updateStatus(0, 'Ready'), 1000);
                renderResults(msg, inputs);
                worker.terminate();
            } else if (msg.type === 'error') { console.error(msg.message); updateStatus(0, 'Error'); }
        };
        updateStatus(0, 'Calculating');
        worker.postMessage(inputs);
    }

    function renderResults(res, inputs) {
        // SAVE DATA FOR EXPORT
        lastResults = res;
        lastInputs = inputs;

        // --- 1. PROFILE CHART ---
        if (currentTab === 'profile') {
            const dx = res.dx * 1e6;
            const labels = Array.from({length: inputs.N}, (_, i) => (i * dx).toFixed(2));
            
            const datasets = res.species.map(s => ({
                label: s.fullLabel,
                data: Array.from(s.C).map(v => v * 100),
                borderColor: s.color, backgroundColor: s.color + '20',
                borderWidth: 2, pointRadius: 0, fill: true,
                // MONOTONE: Fixes staircases without wiggles
                cubicInterpolationMode: 'monotone',
                tension: 0.4
            }));
            
            datasets.unshift({
                label: 'MgO Matrix',
                data: Array.from(res.matrix).map(v => v * 100),
                borderColor: '#6366f1', borderWidth: 2, borderDash: [5,5], 
                pointRadius: 0, fill: false,
                cubicInterpolationMode: 'monotone',
                tension: 0.4
            });
            
            const interfaceXVal = res.interfaceX * 1e6;
            datasets.push({
                label: 'Orig. Interface',
                borderColor: '#64748b', borderWidth: 2, borderDash: [6, 4], 
                pointRadius: 0, fill: false, showLine: true, type: 'scatter',
                data: [{x: interfaceXVal, y: 0}, {x: interfaceXVal, y: 100}]
            });

            if(chartInstance) chartInstance.destroy();

            chartInstance = new Chart(document.getElementById('diffusionChart'), {
    type: 'line', data: { labels, datasets },
    options: { 
        responsive: true, maintainAspectRatio: false, animation: false,
        interaction: { mode: 'index', intersect: false },
        scales: { 
            x: { 
                type: 'linear', 
                min: 0, 
                max: inputs.totalLength, 
                title: {display:true, text:'Depth (µm)'} 
            },
            y: { 
                min: 0,        // <--- ADD THIS LINE (Forces bottom to 0%)
                max: 100,      // Keeps top at 100%
                title: {display:true, text:'Concentration (%)'} 
            }
        }
    }
});

        // --- 2. FLUX CHART ---
        } else if (currentTab === 'flux') {
            const dx = res.dx * 1e6;
            const labels = Array.from({length: inputs.N}, (_, i) => (i * dx).toFixed(2));
            
            let allValues = [];
            const datasets = res.species.map(s => {
                const dataArr = Array.from(s.Flux);
                allValues.push(...dataArr);
                return {
                    label: "Flux " + s.name,
                    data: dataArr,
                    borderColor: s.color, borderWidth: 2, pointRadius: 0,
                    cubicInterpolationMode: 'monotone',
                    tension: 0.4
                };
            });

            const yMin = Math.min(...allValues);
            const yMax = Math.max(...allValues);
            const interfaceXVal = res.interfaceX * 1e6;

            datasets.push({
                label: 'Interface', type: 'scatter',
                data: [{x: interfaceXVal, y: yMin}, {x: interfaceXVal, y: yMax}],
                borderColor: '#64748b', borderWidth: 1, borderDash: [4,4], showLine: true, pointRadius: 0
            });
            
            if(fluxChartInstance) fluxChartInstance.destroy();
            fluxChartInstance = new Chart(document.getElementById('fluxChart'), {
                type: 'line', data: { labels, datasets },
                options: { 
                    responsive: true, maintainAspectRatio: false, animation: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: { 
                        x: { type: 'linear', min: 0, max: inputs.totalLength, title: {display:true, text:'Depth (µm)'} },
                        y: { 
                            title: {display:true, text:'Net Flux (arb. units)'},
                            ticks: { callback: function(value) { return value.toExponential(1); } }
                        } 
                    }
                }
            });

        // --- 3. 3D VIEW ---
        } else if (currentTab === 'time3d') {
            const xData = Array.from({length: inputs.N}, (_, i) => i * (res.dx * 1e6));
            
            const traces = res.species.map(s => {
                const zData = s.history.map(row => Array.from(row).map(v => v*100));
                const yData = Array.from({length: zData.length}, (_, i) => i * (inputs.timeHours/zData.length));
                return {
                    type: 'surface', 
                    x: xData, y: yData, z: zData,
                    name: s.name, 
                    showscale: false, 
                    showlegend: true,
                    opacity: 0.8,
                    colorscale: [ [0, '#ffffff'], [1, s.color] ]
                };
            });

            Plotly.newPlot('plotly-time', traces, {
                margin: {l:0,r:0,b:0,t:30}, 
                showlegend: true,
                legend: { x: 0, y: 1 },
                scene: {
                    xaxis:{title:'Depth (µm)'}, 
                    yaxis:{title:'Time (h)'}, 
                    zaxis:{title:'Conc (%)'}
                }
            });
        }
    }

    // --- DOWNLOAD CSV FUNCTION ---
    function downloadData() {
        if (!lastResults || !lastInputs) {
            alert("No data to download. Please run a calculation first.");
            return;
        }

        let csvContent = "data:text/csv;charset=utf-8,";
        
        // Header: Parameters
        csvContent += "--- SIMULATION PARAMETERS ---\n";
        csvContent += `Temperature (K),${lastInputs.temp}\n`;
        csvContent += `Time (Hours),${lastInputs.timeHours}\n`;
        csvContent += `Source Length (um),${lastInputs.sourceLength}\n`; // Added
        csvContent += `Total Length (um),${lastInputs.totalLength}\n`;   // Added
        csvContent += `Matrix D0 (m2/s),${lastInputs.targetD0}\n`;
        csvContent += `Matrix Q (eV),${lastInputs.targetQ}\n`;
        csvContent += `Grid Points,${lastInputs.N}\n`;
        csvContent += "\n";

        // Header: Dopant Info
        csvContent += "--- SPECIES INFO ---\n";
        csvContent += "Name,D0,Q,C_Left,C_Right\n";
        lastInputs.elements.forEach(el => {
            csvContent += `${el.name},${el.d0},${el.q},${el.cLeft},${el.cRight}\n`;
        });
        csvContent += "\n";

        // Data Body
        csvContent += "--- CALCULATION RESULTS ---\n";
        let headerRow = ["Depth (um)", "Matrix Conc (%)"];
        lastResults.species.forEach(s => {
            headerRow.push(`${s.name} Conc (%)`);
            headerRow.push(`${s.name} Flux (J)`);
        });
        csvContent += headerRow.join(",") + "\n";

        const N = lastInputs.N;
        const dx_um = lastResults.dx * 1e6;

        for (let i = 0; i < N; i++) {
            let row = [];
            row.push((i * dx_um).toFixed(4));
            row.push((lastResults.matrix[i] * 100).toFixed(4));

            lastResults.species.forEach(s => {
                row.push((s.C[i] * 100).toFixed(4));
                row.push((s.Flux[i]).toExponential(4));
            });
            csvContent += row.join(",") + "\n";
        }

        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", `onsager_diffusion_${lastInputs.temp}K_${lastInputs.timeHours}h.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function validateInputs() {
        const elements = [];
        const elCards = document.querySelectorAll('.element-card');
        elCards.forEach(card => {
            const nameSelect = card.querySelector('.el-name');
            elements.push({
                name: nameSelect.options[nameSelect.selectedIndex]?.text.split(' ')[0] || "Unk",
                fullLabel: nameSelect.options[nameSelect.selectedIndex]?.text || "Unknown",
                d0: parseFloat(card.querySelector('.el-d0').value), 
                q: parseFloat(card.querySelector('.el-q').value),
                cLeft: parseFloat(card.querySelector('.el-c-left').value),
                cRight: parseFloat(card.querySelector('.el-c-right').value),
                color: card.querySelector('.el-color').value
            });
        });
        if (elements.length === 0) return null;
        const src = parseFloat(document.getElementById('sourceLength').value);
        const tot = parseFloat(document.getElementById('totalLength').value);
        if(src >= tot) { alert("Source length must be smaller than Total length"); return null; }
        return {
            temp: parseFloat(document.getElementById('temp').value),
            timeHours: parseFloat(document.getElementById('time').value),
            sourceLength: src, totalLength: tot,
            N: parseInt(document.getElementById('gridPoints').value),
            targetD0: parseFloat(document.getElementById('targetD0').value),
            targetQ: parseFloat(document.getElementById('targetQ').value),
            elements
        };
    }

    function debouncedUpdate() { clearTimeout(debounceTimer); debounceTimer = setTimeout(triggerCalculation, 600); }
    function switchTab(tab) {
        currentTab = tab;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.getElementById('tab-' + tab).classList.add('active');
        document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
        document.getElementById('pane-' + tab).classList.add('active');
        if(tab === 'time3d') window.dispatchEvent(new Event('resize'));
        if(tab !== 'help') triggerCalculation();
    }


    function addElement(initialKey = null) {
        const list = document.getElementById('elementsList');
        if (list.children.length >= 4) { alert("Max 4 dopants"); return; }
        
        const template = document.getElementById('elementTemplate');
        const clone = template.content.cloneNode(true);
        const card = clone.querySelector('.element-card');
        
        // 1. Assign Color
        const color = ['#ef4444', '#10b981', '#f59e0b', '#8b5cf6'][list.children.length % 4];
        card.style.borderLeftColor = color;
        clone.querySelector('.el-color').value = color;
        
        // 2. Populate Dropdown
        const select = clone.querySelector('.el-name');
        const keys = Object.keys(CATION_DB);
        keys.forEach(k => {
            const opt = document.createElement('option');
            opt.value = k; opt.text = CATION_DB[k].label;
            select.appendChild(opt);
        });

        // 3. Determine Selection (Use argument or default to first item)
        const selectedKey = initialKey || keys[0]; 
        select.value = selectedKey;

        // 4. Apply Physics Parameters (D0, Q) for the selection
        const data = CATION_DB[selectedKey];
        clone.querySelector('.el-d0').value = data.d0;
        clone.querySelector('.el-q').value = data.q;

        // 5. --- APPLY USER DEFAULTS (25% / 0%) ---
        clone.querySelector('.el-c-left').value = 25; 
        clone.querySelector('.el-c-right').value = 0;

        // 6. Attach Listeners
        clone.querySelector('.delete-btn').onclick = (e) => { 
            e.target.closest('.element-card').remove(); 
            debouncedUpdate(); 
        };
        
        list.appendChild(clone);
        
        // Only trigger calculation if this was a manual button click (not page load)
        if(!initialKey) debouncedUpdate();
    }

    function updateElementParams(select) {
        const data = CATION_DB[select.value];
        const card = select.closest('.element-card');
        card.querySelector('.el-d0').value = data.d0;
        card.querySelector('.el-q').value = data.q;
        debouncedUpdate();
    }

    window.onload = function() { addElement("Ni"); setTimeout(triggerCalculation, 100); };

</script>


</body>
</html>